Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> funcs
Rule 2     prog -> externs funcs
Rule 3     externs -> extern
Rule 4     externs -> extern externs
Rule 5     funcs -> func
Rule 6     funcs -> func funcs
Rule 7     extern -> EXTERN TYPE globid LPAREN RPAREN SEMICOLON
Rule 8     extern -> EXTERN TYPE globid LPAREN tdecls RPAREN SEMICOLON
Rule 9     func -> DEF TYPE globid LPAREN RPAREN blk
Rule 10    func -> DEF TYPE globid LPAREN vdecls RPAREN blk
Rule 11    blk -> LBRACE RBRACE
Rule 12    blk -> LBRACE stmts RBRACE
Rule 13    stmts -> stmt
Rule 14    stmts -> stmt stmts
Rule 15    stmt -> blk
Rule 16    stmt -> RETURN SEMICOLON
Rule 17    stmt -> RETURN exp SEMICOLON
Rule 18    stmt -> vdecl ASSIGN exp SEMICOLON
Rule 19    stmt -> exp SEMICOLON
Rule 20    stmt -> WHILE LPAREN exp RPAREN stmt
Rule 21    stmt -> IF LPAREN exp RPAREN stmt
Rule 22    stmt -> IF LPAREN exp RPAREN stmt ELSE stmt
Rule 23    stmt -> PRINT exp SEMICOLON
Rule 24    stmt -> PRINT slit SEMICOLON
Rule 25    exps -> exp
Rule 26    exps -> exp COMMA exps
Rule 27    exp -> LPAREN exp RPAREN
Rule 28    exp -> binop
Rule 29    exp -> uop
Rule 30    exp -> lit
Rule 31    exp -> varid
Rule 32    exp -> globid LPAREN RPAREN
Rule 33    exp -> globid LPAREN exps RPAREN
Rule 34    binop -> arithOps
Rule 35    binop -> logicOps
Rule 36    binop -> varid ASSIGN exp
Rule 37    binop -> LBRACKET TYPE RBRACKET exp
Rule 38    arithOps -> exp TIMES exp
Rule 39    arithOps -> exp DIVIDE exp
Rule 40    arithOps -> exp PLUS exp
Rule 41    arithOps -> exp MINUS exp
Rule 42    logicOps -> exp EQUAL exp
Rule 43    logicOps -> exp LT exp
Rule 44    logicOps -> exp GT exp
Rule 45    logicOps -> exp AND exp
Rule 46    logicOps -> exp OR exp
Rule 47    uop -> MINUS exp
Rule 48    uop -> NOT exp
Rule 49    lit -> TRUE
Rule 50    lit -> FALSE
Rule 51    lit -> LIT
Rule 52    slit -> SLIT
Rule 53    varid -> VARID
Rule 54    globid -> ID
Rule 55    TYPE -> INT
Rule 56    TYPE -> CINT
Rule 57    TYPE -> FLOAT
Rule 58    TYPE -> BOOL
Rule 59    TYPE -> VOID
Rule 60    TYPE -> REF TYPE
Rule 61    TYPE -> NOALIAS REF TYPE
Rule 62    vdecls -> vdecl
Rule 63    vdecls -> vdecl COMMA vdecls
Rule 64    tdecls -> TYPE
Rule 65    tdecls -> TYPE COMMA tdecls
Rule 66    vdecl -> TYPE varid

Terminals, with rules where they appear

AND                  : 45
ASSIGN               : 18 36
BOOL                 : 58
CINT                 : 56
COMMA                : 26 63 65
DEF                  : 9 10
DIVIDE               : 39
ELSE                 : 22
EQUAL                : 42
EXTERN               : 7 8
FALSE                : 50
FLOAT                : 57
GT                   : 44
ID                   : 54
IF                   : 21 22
INT                  : 55
LBRACE               : 11 12
LBRACKET             : 37
LIT                  : 51
LPAREN               : 7 8 9 10 20 21 22 27 32 33
LT                   : 43
MINUS                : 41 47
NOALIAS              : 61
NOT                  : 48
OR                   : 46
PLUS                 : 40
PRINT                : 23 24
RBRACE               : 11 12
RBRACKET             : 37
REF                  : 60 61
RETURN               : 16 17
RPAREN               : 7 8 9 10 20 21 22 27 32 33
SEMICOLON            : 7 8 16 17 18 19 23 24
SLIT                 : 52
TIMES                : 38
TRUE                 : 49
VARID                : 53
VOID                 : 59
WHILE                : 20
error                : 

Nonterminals, with rules where they appear

TYPE                 : 7 8 9 10 37 60 61 64 65 66
arithOps             : 34
binop                : 28
blk                  : 9 10 15
exp                  : 17 18 19 20 21 22 23 25 26 27 36 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 48
exps                 : 26 33
extern               : 3 4
externs              : 2 4
func                 : 5 6
funcs                : 1 2 6
globid               : 7 8 9 10 32 33
lit                  : 30
logicOps             : 35
prog                 : 0
slit                 : 24
stmt                 : 13 14 20 21 22 22
stmts                : 12 14
tdecls               : 8 65
uop                  : 29
varid                : 31 36 66
vdecl                : 18 62 63
vdecls               : 10 63

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . funcs
    (2) prog -> . externs funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (9) func -> . DEF TYPE globid LPAREN RPAREN blk
    (10) func -> . DEF TYPE globid LPAREN vdecls RPAREN blk
    (7) extern -> . EXTERN TYPE globid LPAREN RPAREN SEMICOLON
    (8) extern -> . EXTERN TYPE globid LPAREN tdecls RPAREN SEMICOLON

    DEF             shift and go to state 6
    EXTERN          shift and go to state 7

    prog                           shift and go to state 1
    funcs                          shift and go to state 2
    externs                        shift and go to state 3
    func                           shift and go to state 4
    extern                         shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> funcs .

    $end            reduce using rule 1 (prog -> funcs .)


state 3

    (2) prog -> externs . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE globid LPAREN RPAREN blk
    (10) func -> . DEF TYPE globid LPAREN vdecls RPAREN blk

    DEF             shift and go to state 6

    funcs                          shift and go to state 8
    func                           shift and go to state 4

state 4

    (5) funcs -> func .
    (6) funcs -> func . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE globid LPAREN RPAREN blk
    (10) func -> . DEF TYPE globid LPAREN vdecls RPAREN blk

    $end            reduce using rule 5 (funcs -> func .)
    DEF             shift and go to state 6

    func                           shift and go to state 4
    funcs                          shift and go to state 9

state 5

    (3) externs -> extern .
    (4) externs -> extern . externs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (7) extern -> . EXTERN TYPE globid LPAREN RPAREN SEMICOLON
    (8) extern -> . EXTERN TYPE globid LPAREN tdecls RPAREN SEMICOLON

    DEF             reduce using rule 3 (externs -> extern .)
    EXTERN          shift and go to state 7

    extern                         shift and go to state 5
    externs                        shift and go to state 10

state 6

    (9) func -> DEF . TYPE globid LPAREN RPAREN blk
    (10) func -> DEF . TYPE globid LPAREN vdecls RPAREN blk
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 11

state 7

    (7) extern -> EXTERN . TYPE globid LPAREN RPAREN SEMICOLON
    (8) extern -> EXTERN . TYPE globid LPAREN tdecls RPAREN SEMICOLON
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 19

state 8

    (2) prog -> externs funcs .

    $end            reduce using rule 2 (prog -> externs funcs .)


state 9

    (6) funcs -> func funcs .

    $end            reduce using rule 6 (funcs -> func funcs .)


state 10

    (4) externs -> extern externs .

    DEF             reduce using rule 4 (externs -> extern externs .)


state 11

    (9) func -> DEF TYPE . globid LPAREN RPAREN blk
    (10) func -> DEF TYPE . globid LPAREN vdecls RPAREN blk
    (54) globid -> . ID

    ID              shift and go to state 21

    globid                         shift and go to state 20

state 12

    (55) TYPE -> INT .

    ID              reduce using rule 55 (TYPE -> INT .)
    VARID           reduce using rule 55 (TYPE -> INT .)
    COMMA           reduce using rule 55 (TYPE -> INT .)
    RPAREN          reduce using rule 55 (TYPE -> INT .)
    RBRACKET        reduce using rule 55 (TYPE -> INT .)


state 13

    (56) TYPE -> CINT .

    ID              reduce using rule 56 (TYPE -> CINT .)
    VARID           reduce using rule 56 (TYPE -> CINT .)
    COMMA           reduce using rule 56 (TYPE -> CINT .)
    RPAREN          reduce using rule 56 (TYPE -> CINT .)
    RBRACKET        reduce using rule 56 (TYPE -> CINT .)


state 14

    (57) TYPE -> FLOAT .

    ID              reduce using rule 57 (TYPE -> FLOAT .)
    VARID           reduce using rule 57 (TYPE -> FLOAT .)
    COMMA           reduce using rule 57 (TYPE -> FLOAT .)
    RPAREN          reduce using rule 57 (TYPE -> FLOAT .)
    RBRACKET        reduce using rule 57 (TYPE -> FLOAT .)


state 15

    (58) TYPE -> BOOL .

    ID              reduce using rule 58 (TYPE -> BOOL .)
    VARID           reduce using rule 58 (TYPE -> BOOL .)
    COMMA           reduce using rule 58 (TYPE -> BOOL .)
    RPAREN          reduce using rule 58 (TYPE -> BOOL .)
    RBRACKET        reduce using rule 58 (TYPE -> BOOL .)


state 16

    (59) TYPE -> VOID .

    ID              reduce using rule 59 (TYPE -> VOID .)
    VARID           reduce using rule 59 (TYPE -> VOID .)
    COMMA           reduce using rule 59 (TYPE -> VOID .)
    RPAREN          reduce using rule 59 (TYPE -> VOID .)
    RBRACKET        reduce using rule 59 (TYPE -> VOID .)


state 17

    (60) TYPE -> REF . TYPE
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 22

state 18

    (61) TYPE -> NOALIAS . REF TYPE

    REF             shift and go to state 23


state 19

    (7) extern -> EXTERN TYPE . globid LPAREN RPAREN SEMICOLON
    (8) extern -> EXTERN TYPE . globid LPAREN tdecls RPAREN SEMICOLON
    (54) globid -> . ID

    ID              shift and go to state 21

    globid                         shift and go to state 24

state 20

    (9) func -> DEF TYPE globid . LPAREN RPAREN blk
    (10) func -> DEF TYPE globid . LPAREN vdecls RPAREN blk

    LPAREN          shift and go to state 25


state 21

    (54) globid -> ID .

    LPAREN          reduce using rule 54 (globid -> ID .)


state 22

    (60) TYPE -> REF TYPE .

    ID              reduce using rule 60 (TYPE -> REF TYPE .)
    VARID           reduce using rule 60 (TYPE -> REF TYPE .)
    COMMA           reduce using rule 60 (TYPE -> REF TYPE .)
    RPAREN          reduce using rule 60 (TYPE -> REF TYPE .)
    RBRACKET        reduce using rule 60 (TYPE -> REF TYPE .)


state 23

    (61) TYPE -> NOALIAS REF . TYPE
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 26

state 24

    (7) extern -> EXTERN TYPE globid . LPAREN RPAREN SEMICOLON
    (8) extern -> EXTERN TYPE globid . LPAREN tdecls RPAREN SEMICOLON

    LPAREN          shift and go to state 27


state 25

    (9) func -> DEF TYPE globid LPAREN . RPAREN blk
    (10) func -> DEF TYPE globid LPAREN . vdecls RPAREN blk
    (62) vdecls -> . vdecl
    (63) vdecls -> . vdecl COMMA vdecls
    (66) vdecl -> . TYPE varid
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    RPAREN          shift and go to state 29
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 28
    vdecls                         shift and go to state 30
    vdecl                          shift and go to state 31

state 26

    (61) TYPE -> NOALIAS REF TYPE .

    ID              reduce using rule 61 (TYPE -> NOALIAS REF TYPE .)
    VARID           reduce using rule 61 (TYPE -> NOALIAS REF TYPE .)
    COMMA           reduce using rule 61 (TYPE -> NOALIAS REF TYPE .)
    RPAREN          reduce using rule 61 (TYPE -> NOALIAS REF TYPE .)
    RBRACKET        reduce using rule 61 (TYPE -> NOALIAS REF TYPE .)


state 27

    (7) extern -> EXTERN TYPE globid LPAREN . RPAREN SEMICOLON
    (8) extern -> EXTERN TYPE globid LPAREN . tdecls RPAREN SEMICOLON
    (64) tdecls -> . TYPE
    (65) tdecls -> . TYPE COMMA tdecls
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    RPAREN          shift and go to state 33
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 32
    tdecls                         shift and go to state 34

state 28

    (66) vdecl -> TYPE . varid
    (53) varid -> . VARID

    VARID           shift and go to state 36

    varid                          shift and go to state 35

state 29

    (9) func -> DEF TYPE globid LPAREN RPAREN . blk
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 38

    blk                            shift and go to state 37

state 30

    (10) func -> DEF TYPE globid LPAREN vdecls . RPAREN blk

    RPAREN          shift and go to state 39


state 31

    (62) vdecls -> vdecl .
    (63) vdecls -> vdecl . COMMA vdecls

    RPAREN          reduce using rule 62 (vdecls -> vdecl .)
    COMMA           shift and go to state 40


state 32

    (64) tdecls -> TYPE .
    (65) tdecls -> TYPE . COMMA tdecls

    RPAREN          reduce using rule 64 (tdecls -> TYPE .)
    COMMA           shift and go to state 41


state 33

    (7) extern -> EXTERN TYPE globid LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 42


state 34

    (8) extern -> EXTERN TYPE globid LPAREN tdecls . RPAREN SEMICOLON

    RPAREN          shift and go to state 43


state 35

    (66) vdecl -> TYPE varid .

    COMMA           reduce using rule 66 (vdecl -> TYPE varid .)
    RPAREN          reduce using rule 66 (vdecl -> TYPE varid .)
    ASSIGN          reduce using rule 66 (vdecl -> TYPE varid .)


state 36

    (53) varid -> VARID .

    COMMA           reduce using rule 53 (varid -> VARID .)
    RPAREN          reduce using rule 53 (varid -> VARID .)
    ASSIGN          reduce using rule 53 (varid -> VARID .)
    SEMICOLON       reduce using rule 53 (varid -> VARID .)
    TIMES           reduce using rule 53 (varid -> VARID .)
    DIVIDE          reduce using rule 53 (varid -> VARID .)
    PLUS            reduce using rule 53 (varid -> VARID .)
    MINUS           reduce using rule 53 (varid -> VARID .)
    EQUAL           reduce using rule 53 (varid -> VARID .)
    LT              reduce using rule 53 (varid -> VARID .)
    GT              reduce using rule 53 (varid -> VARID .)
    AND             reduce using rule 53 (varid -> VARID .)
    OR              reduce using rule 53 (varid -> VARID .)


state 37

    (9) func -> DEF TYPE globid LPAREN RPAREN blk .

    DEF             reduce using rule 9 (func -> DEF TYPE globid LPAREN RPAREN blk .)
    $end            reduce using rule 9 (func -> DEF TYPE globid LPAREN RPAREN blk .)


state 38

    (11) blk -> LBRACE . RBRACE
    (12) blk -> LBRACE . stmts RBRACE
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl ASSIGN exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT slit SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE
    (66) vdecl -> . TYPE varid
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    RBRACE          shift and go to state 44
    RETURN          shift and go to state 48
    WHILE           shift and go to state 51
    IF              shift and go to state 53
    PRINT           shift and go to state 54
    LBRACE          shift and go to state 38
    LPAREN          shift and go to state 52
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    stmts                          shift and go to state 45
    stmt                           shift and go to state 46
    blk                            shift and go to state 47
    exp                            shift and go to state 49
    vdecl                          shift and go to state 50
    TYPE                           shift and go to state 28
    varid                          shift and go to state 55
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 39

    (10) func -> DEF TYPE globid LPAREN vdecls RPAREN . blk
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 38

    blk                            shift and go to state 68

state 40

    (63) vdecls -> vdecl COMMA . vdecls
    (62) vdecls -> . vdecl
    (63) vdecls -> . vdecl COMMA vdecls
    (66) vdecl -> . TYPE varid
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    vdecl                          shift and go to state 31
    vdecls                         shift and go to state 69
    TYPE                           shift and go to state 28

state 41

    (65) tdecls -> TYPE COMMA . tdecls
    (64) tdecls -> . TYPE
    (65) tdecls -> . TYPE COMMA tdecls
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 32
    tdecls                         shift and go to state 70

state 42

    (7) extern -> EXTERN TYPE globid LPAREN RPAREN SEMICOLON .

    EXTERN          reduce using rule 7 (extern -> EXTERN TYPE globid LPAREN RPAREN SEMICOLON .)
    DEF             reduce using rule 7 (extern -> EXTERN TYPE globid LPAREN RPAREN SEMICOLON .)


state 43

    (8) extern -> EXTERN TYPE globid LPAREN tdecls RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 71


state 44

    (11) blk -> LBRACE RBRACE .

    DEF             reduce using rule 11 (blk -> LBRACE RBRACE .)
    $end            reduce using rule 11 (blk -> LBRACE RBRACE .)
    RETURN          reduce using rule 11 (blk -> LBRACE RBRACE .)
    WHILE           reduce using rule 11 (blk -> LBRACE RBRACE .)
    IF              reduce using rule 11 (blk -> LBRACE RBRACE .)
    PRINT           reduce using rule 11 (blk -> LBRACE RBRACE .)
    LBRACE          reduce using rule 11 (blk -> LBRACE RBRACE .)
    LPAREN          reduce using rule 11 (blk -> LBRACE RBRACE .)
    INT             reduce using rule 11 (blk -> LBRACE RBRACE .)
    CINT            reduce using rule 11 (blk -> LBRACE RBRACE .)
    FLOAT           reduce using rule 11 (blk -> LBRACE RBRACE .)
    BOOL            reduce using rule 11 (blk -> LBRACE RBRACE .)
    VOID            reduce using rule 11 (blk -> LBRACE RBRACE .)
    REF             reduce using rule 11 (blk -> LBRACE RBRACE .)
    NOALIAS         reduce using rule 11 (blk -> LBRACE RBRACE .)
    LBRACKET        reduce using rule 11 (blk -> LBRACE RBRACE .)
    MINUS           reduce using rule 11 (blk -> LBRACE RBRACE .)
    NOT             reduce using rule 11 (blk -> LBRACE RBRACE .)
    TRUE            reduce using rule 11 (blk -> LBRACE RBRACE .)
    FALSE           reduce using rule 11 (blk -> LBRACE RBRACE .)
    LIT             reduce using rule 11 (blk -> LBRACE RBRACE .)
    VARID           reduce using rule 11 (blk -> LBRACE RBRACE .)
    ID              reduce using rule 11 (blk -> LBRACE RBRACE .)
    RBRACE          reduce using rule 11 (blk -> LBRACE RBRACE .)
    ELSE            reduce using rule 11 (blk -> LBRACE RBRACE .)


state 45

    (12) blk -> LBRACE stmts . RBRACE

    RBRACE          shift and go to state 72


state 46

    (13) stmts -> stmt .
    (14) stmts -> stmt . stmts
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl ASSIGN exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT slit SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE
    (66) vdecl -> . TYPE varid
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    RBRACE          reduce using rule 13 (stmts -> stmt .)
    RETURN          shift and go to state 48
    WHILE           shift and go to state 51
    IF              shift and go to state 53
    PRINT           shift and go to state 54
    LBRACE          shift and go to state 38
    LPAREN          shift and go to state 52
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    stmt                           shift and go to state 46
    stmts                          shift and go to state 73
    blk                            shift and go to state 47
    exp                            shift and go to state 49
    vdecl                          shift and go to state 50
    TYPE                           shift and go to state 28
    varid                          shift and go to state 55
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 47

    (15) stmt -> blk .

    RETURN          reduce using rule 15 (stmt -> blk .)
    WHILE           reduce using rule 15 (stmt -> blk .)
    IF              reduce using rule 15 (stmt -> blk .)
    PRINT           reduce using rule 15 (stmt -> blk .)
    LBRACE          reduce using rule 15 (stmt -> blk .)
    LPAREN          reduce using rule 15 (stmt -> blk .)
    INT             reduce using rule 15 (stmt -> blk .)
    CINT            reduce using rule 15 (stmt -> blk .)
    FLOAT           reduce using rule 15 (stmt -> blk .)
    BOOL            reduce using rule 15 (stmt -> blk .)
    VOID            reduce using rule 15 (stmt -> blk .)
    REF             reduce using rule 15 (stmt -> blk .)
    NOALIAS         reduce using rule 15 (stmt -> blk .)
    LBRACKET        reduce using rule 15 (stmt -> blk .)
    MINUS           reduce using rule 15 (stmt -> blk .)
    NOT             reduce using rule 15 (stmt -> blk .)
    TRUE            reduce using rule 15 (stmt -> blk .)
    FALSE           reduce using rule 15 (stmt -> blk .)
    LIT             reduce using rule 15 (stmt -> blk .)
    VARID           reduce using rule 15 (stmt -> blk .)
    ID              reduce using rule 15 (stmt -> blk .)
    RBRACE          reduce using rule 15 (stmt -> blk .)
    ELSE            reduce using rule 15 (stmt -> blk .)


state 48

    (16) stmt -> RETURN . SEMICOLON
    (17) stmt -> RETURN . exp SEMICOLON
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    SEMICOLON       shift and go to state 74
    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 75
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 49

    (19) stmt -> exp . SEMICOLON
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       shift and go to state 76
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 50

    (18) stmt -> vdecl . ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 86


state 51

    (20) stmt -> WHILE . LPAREN exp RPAREN stmt

    LPAREN          shift and go to state 87


state 52

    (27) exp -> LPAREN . exp RPAREN
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 88
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 53

    (21) stmt -> IF . LPAREN exp RPAREN stmt
    (22) stmt -> IF . LPAREN exp RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 89


state 54

    (23) stmt -> PRINT . exp SEMICOLON
    (24) stmt -> PRINT . slit SEMICOLON
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (52) slit -> . SLIT
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    SLIT            shift and go to state 92
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 90
    slit                           shift and go to state 91
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 55

    (31) exp -> varid .
    (36) binop -> varid . ASSIGN exp

    SEMICOLON       reduce using rule 31 (exp -> varid .)
    TIMES           reduce using rule 31 (exp -> varid .)
    DIVIDE          reduce using rule 31 (exp -> varid .)
    PLUS            reduce using rule 31 (exp -> varid .)
    MINUS           reduce using rule 31 (exp -> varid .)
    EQUAL           reduce using rule 31 (exp -> varid .)
    LT              reduce using rule 31 (exp -> varid .)
    GT              reduce using rule 31 (exp -> varid .)
    AND             reduce using rule 31 (exp -> varid .)
    OR              reduce using rule 31 (exp -> varid .)
    RPAREN          reduce using rule 31 (exp -> varid .)
    COMMA           reduce using rule 31 (exp -> varid .)
    ASSIGN          shift and go to state 93


state 56

    (28) exp -> binop .

    SEMICOLON       reduce using rule 28 (exp -> binop .)
    TIMES           reduce using rule 28 (exp -> binop .)
    DIVIDE          reduce using rule 28 (exp -> binop .)
    PLUS            reduce using rule 28 (exp -> binop .)
    MINUS           reduce using rule 28 (exp -> binop .)
    EQUAL           reduce using rule 28 (exp -> binop .)
    LT              reduce using rule 28 (exp -> binop .)
    GT              reduce using rule 28 (exp -> binop .)
    AND             reduce using rule 28 (exp -> binop .)
    OR              reduce using rule 28 (exp -> binop .)
    RPAREN          reduce using rule 28 (exp -> binop .)
    COMMA           reduce using rule 28 (exp -> binop .)


state 57

    (29) exp -> uop .

    SEMICOLON       reduce using rule 29 (exp -> uop .)
    TIMES           reduce using rule 29 (exp -> uop .)
    DIVIDE          reduce using rule 29 (exp -> uop .)
    PLUS            reduce using rule 29 (exp -> uop .)
    MINUS           reduce using rule 29 (exp -> uop .)
    EQUAL           reduce using rule 29 (exp -> uop .)
    LT              reduce using rule 29 (exp -> uop .)
    GT              reduce using rule 29 (exp -> uop .)
    AND             reduce using rule 29 (exp -> uop .)
    OR              reduce using rule 29 (exp -> uop .)
    RPAREN          reduce using rule 29 (exp -> uop .)
    COMMA           reduce using rule 29 (exp -> uop .)


state 58

    (30) exp -> lit .

    SEMICOLON       reduce using rule 30 (exp -> lit .)
    TIMES           reduce using rule 30 (exp -> lit .)
    DIVIDE          reduce using rule 30 (exp -> lit .)
    PLUS            reduce using rule 30 (exp -> lit .)
    MINUS           reduce using rule 30 (exp -> lit .)
    EQUAL           reduce using rule 30 (exp -> lit .)
    LT              reduce using rule 30 (exp -> lit .)
    GT              reduce using rule 30 (exp -> lit .)
    AND             reduce using rule 30 (exp -> lit .)
    OR              reduce using rule 30 (exp -> lit .)
    RPAREN          reduce using rule 30 (exp -> lit .)
    COMMA           reduce using rule 30 (exp -> lit .)


state 59

    (32) exp -> globid . LPAREN RPAREN
    (33) exp -> globid . LPAREN exps RPAREN

    LPAREN          shift and go to state 94


state 60

    (34) binop -> arithOps .

    SEMICOLON       reduce using rule 34 (binop -> arithOps .)
    TIMES           reduce using rule 34 (binop -> arithOps .)
    DIVIDE          reduce using rule 34 (binop -> arithOps .)
    PLUS            reduce using rule 34 (binop -> arithOps .)
    MINUS           reduce using rule 34 (binop -> arithOps .)
    EQUAL           reduce using rule 34 (binop -> arithOps .)
    LT              reduce using rule 34 (binop -> arithOps .)
    GT              reduce using rule 34 (binop -> arithOps .)
    AND             reduce using rule 34 (binop -> arithOps .)
    OR              reduce using rule 34 (binop -> arithOps .)
    RPAREN          reduce using rule 34 (binop -> arithOps .)
    COMMA           reduce using rule 34 (binop -> arithOps .)


state 61

    (35) binop -> logicOps .

    SEMICOLON       reduce using rule 35 (binop -> logicOps .)
    TIMES           reduce using rule 35 (binop -> logicOps .)
    DIVIDE          reduce using rule 35 (binop -> logicOps .)
    PLUS            reduce using rule 35 (binop -> logicOps .)
    MINUS           reduce using rule 35 (binop -> logicOps .)
    EQUAL           reduce using rule 35 (binop -> logicOps .)
    LT              reduce using rule 35 (binop -> logicOps .)
    GT              reduce using rule 35 (binop -> logicOps .)
    AND             reduce using rule 35 (binop -> logicOps .)
    OR              reduce using rule 35 (binop -> logicOps .)
    RPAREN          reduce using rule 35 (binop -> logicOps .)
    COMMA           reduce using rule 35 (binop -> logicOps .)


state 62

    (37) binop -> LBRACKET . TYPE RBRACKET exp
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE

    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18

    TYPE                           shift and go to state 95

state 63

    (47) uop -> MINUS . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 96
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 64

    (48) uop -> NOT . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 97
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 65

    (49) lit -> TRUE .

    SEMICOLON       reduce using rule 49 (lit -> TRUE .)
    TIMES           reduce using rule 49 (lit -> TRUE .)
    DIVIDE          reduce using rule 49 (lit -> TRUE .)
    PLUS            reduce using rule 49 (lit -> TRUE .)
    MINUS           reduce using rule 49 (lit -> TRUE .)
    EQUAL           reduce using rule 49 (lit -> TRUE .)
    LT              reduce using rule 49 (lit -> TRUE .)
    GT              reduce using rule 49 (lit -> TRUE .)
    AND             reduce using rule 49 (lit -> TRUE .)
    OR              reduce using rule 49 (lit -> TRUE .)
    RPAREN          reduce using rule 49 (lit -> TRUE .)
    COMMA           reduce using rule 49 (lit -> TRUE .)


state 66

    (50) lit -> FALSE .

    SEMICOLON       reduce using rule 50 (lit -> FALSE .)
    TIMES           reduce using rule 50 (lit -> FALSE .)
    DIVIDE          reduce using rule 50 (lit -> FALSE .)
    PLUS            reduce using rule 50 (lit -> FALSE .)
    MINUS           reduce using rule 50 (lit -> FALSE .)
    EQUAL           reduce using rule 50 (lit -> FALSE .)
    LT              reduce using rule 50 (lit -> FALSE .)
    GT              reduce using rule 50 (lit -> FALSE .)
    AND             reduce using rule 50 (lit -> FALSE .)
    OR              reduce using rule 50 (lit -> FALSE .)
    RPAREN          reduce using rule 50 (lit -> FALSE .)
    COMMA           reduce using rule 50 (lit -> FALSE .)


state 67

    (51) lit -> LIT .

    SEMICOLON       reduce using rule 51 (lit -> LIT .)
    TIMES           reduce using rule 51 (lit -> LIT .)
    DIVIDE          reduce using rule 51 (lit -> LIT .)
    PLUS            reduce using rule 51 (lit -> LIT .)
    MINUS           reduce using rule 51 (lit -> LIT .)
    EQUAL           reduce using rule 51 (lit -> LIT .)
    LT              reduce using rule 51 (lit -> LIT .)
    GT              reduce using rule 51 (lit -> LIT .)
    AND             reduce using rule 51 (lit -> LIT .)
    OR              reduce using rule 51 (lit -> LIT .)
    RPAREN          reduce using rule 51 (lit -> LIT .)
    COMMA           reduce using rule 51 (lit -> LIT .)


state 68

    (10) func -> DEF TYPE globid LPAREN vdecls RPAREN blk .

    DEF             reduce using rule 10 (func -> DEF TYPE globid LPAREN vdecls RPAREN blk .)
    $end            reduce using rule 10 (func -> DEF TYPE globid LPAREN vdecls RPAREN blk .)


state 69

    (63) vdecls -> vdecl COMMA vdecls .

    RPAREN          reduce using rule 63 (vdecls -> vdecl COMMA vdecls .)


state 70

    (65) tdecls -> TYPE COMMA tdecls .

    RPAREN          reduce using rule 65 (tdecls -> TYPE COMMA tdecls .)


state 71

    (8) extern -> EXTERN TYPE globid LPAREN tdecls RPAREN SEMICOLON .

    EXTERN          reduce using rule 8 (extern -> EXTERN TYPE globid LPAREN tdecls RPAREN SEMICOLON .)
    DEF             reduce using rule 8 (extern -> EXTERN TYPE globid LPAREN tdecls RPAREN SEMICOLON .)


state 72

    (12) blk -> LBRACE stmts RBRACE .

    DEF             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    $end            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    RETURN          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    WHILE           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    IF              reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    PRINT           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    LBRACE          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    LPAREN          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    INT             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    CINT            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    FLOAT           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    BOOL            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    VOID            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    REF             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    NOALIAS         reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    LBRACKET        reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    MINUS           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    NOT             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    TRUE            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    FALSE           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    LIT             reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    VARID           reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    ID              reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 12 (blk -> LBRACE stmts RBRACE .)
    ELSE            reduce using rule 12 (blk -> LBRACE stmts RBRACE .)


state 73

    (14) stmts -> stmt stmts .

    RBRACE          reduce using rule 14 (stmts -> stmt stmts .)


state 74

    (16) stmt -> RETURN SEMICOLON .

    RETURN          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    PRINT           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    CINT            reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    BOOL            reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    VOID            reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    REF             reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    NOALIAS         reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    LBRACKET        reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    MINUS           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    NOT             reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    LIT             reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    VARID           reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 16 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 16 (stmt -> RETURN SEMICOLON .)


state 75

    (17) stmt -> RETURN exp . SEMICOLON
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       shift and go to state 98
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 76

    (19) stmt -> exp SEMICOLON .

    RETURN          reduce using rule 19 (stmt -> exp SEMICOLON .)
    WHILE           reduce using rule 19 (stmt -> exp SEMICOLON .)
    IF              reduce using rule 19 (stmt -> exp SEMICOLON .)
    PRINT           reduce using rule 19 (stmt -> exp SEMICOLON .)
    LBRACE          reduce using rule 19 (stmt -> exp SEMICOLON .)
    LPAREN          reduce using rule 19 (stmt -> exp SEMICOLON .)
    INT             reduce using rule 19 (stmt -> exp SEMICOLON .)
    CINT            reduce using rule 19 (stmt -> exp SEMICOLON .)
    FLOAT           reduce using rule 19 (stmt -> exp SEMICOLON .)
    BOOL            reduce using rule 19 (stmt -> exp SEMICOLON .)
    VOID            reduce using rule 19 (stmt -> exp SEMICOLON .)
    REF             reduce using rule 19 (stmt -> exp SEMICOLON .)
    NOALIAS         reduce using rule 19 (stmt -> exp SEMICOLON .)
    LBRACKET        reduce using rule 19 (stmt -> exp SEMICOLON .)
    MINUS           reduce using rule 19 (stmt -> exp SEMICOLON .)
    NOT             reduce using rule 19 (stmt -> exp SEMICOLON .)
    TRUE            reduce using rule 19 (stmt -> exp SEMICOLON .)
    FALSE           reduce using rule 19 (stmt -> exp SEMICOLON .)
    LIT             reduce using rule 19 (stmt -> exp SEMICOLON .)
    VARID           reduce using rule 19 (stmt -> exp SEMICOLON .)
    ID              reduce using rule 19 (stmt -> exp SEMICOLON .)
    RBRACE          reduce using rule 19 (stmt -> exp SEMICOLON .)
    ELSE            reduce using rule 19 (stmt -> exp SEMICOLON .)


state 77

    (38) arithOps -> exp TIMES . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 99
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 78

    (39) arithOps -> exp DIVIDE . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 100
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 79

    (40) arithOps -> exp PLUS . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 101
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 80

    (41) arithOps -> exp MINUS . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 102
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 81

    (42) logicOps -> exp EQUAL . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 103
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 82

    (43) logicOps -> exp LT . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 104
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 83

    (44) logicOps -> exp GT . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 105
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 84

    (45) logicOps -> exp AND . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 106
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 85

    (46) logicOps -> exp OR . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 107
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 86

    (18) stmt -> vdecl ASSIGN . exp SEMICOLON
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 108
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 87

    (20) stmt -> WHILE LPAREN . exp RPAREN stmt
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 109
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 88

    (27) exp -> LPAREN exp . RPAREN
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    RPAREN          shift and go to state 110
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 89

    (21) stmt -> IF LPAREN . exp RPAREN stmt
    (22) stmt -> IF LPAREN . exp RPAREN stmt ELSE stmt
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 111
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 90

    (23) stmt -> PRINT exp . SEMICOLON
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       shift and go to state 112
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 91

    (24) stmt -> PRINT slit . SEMICOLON

    SEMICOLON       shift and go to state 113


state 92

    (52) slit -> SLIT .

    SEMICOLON       reduce using rule 52 (slit -> SLIT .)


state 93

    (36) binop -> varid ASSIGN . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    varid                          shift and go to state 55
    exp                            shift and go to state 114
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 94

    (32) exp -> globid LPAREN . RPAREN
    (33) exp -> globid LPAREN . exps RPAREN
    (25) exps -> . exp
    (26) exps -> . exp COMMA exps
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    RPAREN          shift and go to state 115
    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    globid                         shift and go to state 59
    exps                           shift and go to state 116
    exp                            shift and go to state 117
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 95

    (37) binop -> LBRACKET TYPE . RBRACKET exp

    RBRACKET        shift and go to state 118


state 96

    (47) uop -> MINUS exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 47 (uop -> MINUS exp .)
    TIMES           reduce using rule 47 (uop -> MINUS exp .)
    DIVIDE          reduce using rule 47 (uop -> MINUS exp .)
    PLUS            reduce using rule 47 (uop -> MINUS exp .)
    MINUS           reduce using rule 47 (uop -> MINUS exp .)
    EQUAL           reduce using rule 47 (uop -> MINUS exp .)
    LT              reduce using rule 47 (uop -> MINUS exp .)
    GT              reduce using rule 47 (uop -> MINUS exp .)
    AND             reduce using rule 47 (uop -> MINUS exp .)
    OR              reduce using rule 47 (uop -> MINUS exp .)
    RPAREN          reduce using rule 47 (uop -> MINUS exp .)
    COMMA           reduce using rule 47 (uop -> MINUS exp .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 97

    (48) uop -> NOT exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 48 (uop -> NOT exp .)
    TIMES           reduce using rule 48 (uop -> NOT exp .)
    DIVIDE          reduce using rule 48 (uop -> NOT exp .)
    PLUS            reduce using rule 48 (uop -> NOT exp .)
    MINUS           reduce using rule 48 (uop -> NOT exp .)
    EQUAL           reduce using rule 48 (uop -> NOT exp .)
    LT              reduce using rule 48 (uop -> NOT exp .)
    GT              reduce using rule 48 (uop -> NOT exp .)
    AND             reduce using rule 48 (uop -> NOT exp .)
    OR              reduce using rule 48 (uop -> NOT exp .)
    RPAREN          reduce using rule 48 (uop -> NOT exp .)
    COMMA           reduce using rule 48 (uop -> NOT exp .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 98

    (17) stmt -> RETURN exp SEMICOLON .

    RETURN          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    IF              reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    LBRACE          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    LPAREN          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    INT             reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    CINT            reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    BOOL            reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    VOID            reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    REF             reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    NOALIAS         reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    LBRACKET        reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    MINUS           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    NOT             reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    TRUE            reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    FALSE           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    LIT             reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    VARID           reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    RBRACE          reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)
    ELSE            reduce using rule 17 (stmt -> RETURN exp SEMICOLON .)


state 99

    (38) arithOps -> exp TIMES exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 38 (arithOps -> exp TIMES exp .)
    TIMES           reduce using rule 38 (arithOps -> exp TIMES exp .)
    DIVIDE          reduce using rule 38 (arithOps -> exp TIMES exp .)
    PLUS            reduce using rule 38 (arithOps -> exp TIMES exp .)
    MINUS           reduce using rule 38 (arithOps -> exp TIMES exp .)
    EQUAL           reduce using rule 38 (arithOps -> exp TIMES exp .)
    LT              reduce using rule 38 (arithOps -> exp TIMES exp .)
    GT              reduce using rule 38 (arithOps -> exp TIMES exp .)
    AND             reduce using rule 38 (arithOps -> exp TIMES exp .)
    OR              reduce using rule 38 (arithOps -> exp TIMES exp .)
    RPAREN          reduce using rule 38 (arithOps -> exp TIMES exp .)
    COMMA           reduce using rule 38 (arithOps -> exp TIMES exp .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 100

    (39) arithOps -> exp DIVIDE exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    TIMES           reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    PLUS            reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    MINUS           reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    EQUAL           reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    LT              reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    GT              reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    AND             reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    OR              reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    RPAREN          reduce using rule 39 (arithOps -> exp DIVIDE exp .)
    COMMA           reduce using rule 39 (arithOps -> exp DIVIDE exp .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 101

    (40) arithOps -> exp PLUS exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 40 (arithOps -> exp PLUS exp .)
    PLUS            reduce using rule 40 (arithOps -> exp PLUS exp .)
    MINUS           reduce using rule 40 (arithOps -> exp PLUS exp .)
    EQUAL           reduce using rule 40 (arithOps -> exp PLUS exp .)
    LT              reduce using rule 40 (arithOps -> exp PLUS exp .)
    GT              reduce using rule 40 (arithOps -> exp PLUS exp .)
    AND             reduce using rule 40 (arithOps -> exp PLUS exp .)
    OR              reduce using rule 40 (arithOps -> exp PLUS exp .)
    RPAREN          reduce using rule 40 (arithOps -> exp PLUS exp .)
    COMMA           reduce using rule 40 (arithOps -> exp PLUS exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78

  ! TIMES           [ reduce using rule 40 (arithOps -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 40 (arithOps -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 102

    (41) arithOps -> exp MINUS exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 41 (arithOps -> exp MINUS exp .)
    PLUS            reduce using rule 41 (arithOps -> exp MINUS exp .)
    MINUS           reduce using rule 41 (arithOps -> exp MINUS exp .)
    EQUAL           reduce using rule 41 (arithOps -> exp MINUS exp .)
    LT              reduce using rule 41 (arithOps -> exp MINUS exp .)
    GT              reduce using rule 41 (arithOps -> exp MINUS exp .)
    AND             reduce using rule 41 (arithOps -> exp MINUS exp .)
    OR              reduce using rule 41 (arithOps -> exp MINUS exp .)
    RPAREN          reduce using rule 41 (arithOps -> exp MINUS exp .)
    COMMA           reduce using rule 41 (arithOps -> exp MINUS exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78

  ! TIMES           [ reduce using rule 41 (arithOps -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 41 (arithOps -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 103

    (42) logicOps -> exp EQUAL exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 42 (logicOps -> exp EQUAL exp .)
    EQUAL           reduce using rule 42 (logicOps -> exp EQUAL exp .)
    AND             reduce using rule 42 (logicOps -> exp EQUAL exp .)
    OR              reduce using rule 42 (logicOps -> exp EQUAL exp .)
    RPAREN          reduce using rule 42 (logicOps -> exp EQUAL exp .)
    COMMA           reduce using rule 42 (logicOps -> exp EQUAL exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    LT              shift and go to state 82
    GT              shift and go to state 83

  ! TIMES           [ reduce using rule 42 (logicOps -> exp EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 42 (logicOps -> exp EQUAL exp .) ]
  ! PLUS            [ reduce using rule 42 (logicOps -> exp EQUAL exp .) ]
  ! MINUS           [ reduce using rule 42 (logicOps -> exp EQUAL exp .) ]
  ! LT              [ reduce using rule 42 (logicOps -> exp EQUAL exp .) ]
  ! GT              [ reduce using rule 42 (logicOps -> exp EQUAL exp .) ]
  ! EQUAL           [ shift and go to state 81 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 104

    (43) logicOps -> exp LT exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 43 (logicOps -> exp LT exp .)
    EQUAL           reduce using rule 43 (logicOps -> exp LT exp .)
    LT              reduce using rule 43 (logicOps -> exp LT exp .)
    GT              reduce using rule 43 (logicOps -> exp LT exp .)
    AND             reduce using rule 43 (logicOps -> exp LT exp .)
    OR              reduce using rule 43 (logicOps -> exp LT exp .)
    RPAREN          reduce using rule 43 (logicOps -> exp LT exp .)
    COMMA           reduce using rule 43 (logicOps -> exp LT exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80

  ! TIMES           [ reduce using rule 43 (logicOps -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 43 (logicOps -> exp LT exp .) ]
  ! PLUS            [ reduce using rule 43 (logicOps -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 43 (logicOps -> exp LT exp .) ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 105

    (44) logicOps -> exp GT exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 44 (logicOps -> exp GT exp .)
    EQUAL           reduce using rule 44 (logicOps -> exp GT exp .)
    LT              reduce using rule 44 (logicOps -> exp GT exp .)
    GT              reduce using rule 44 (logicOps -> exp GT exp .)
    AND             reduce using rule 44 (logicOps -> exp GT exp .)
    OR              reduce using rule 44 (logicOps -> exp GT exp .)
    RPAREN          reduce using rule 44 (logicOps -> exp GT exp .)
    COMMA           reduce using rule 44 (logicOps -> exp GT exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80

  ! TIMES           [ reduce using rule 44 (logicOps -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 44 (logicOps -> exp GT exp .) ]
  ! PLUS            [ reduce using rule 44 (logicOps -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 44 (logicOps -> exp GT exp .) ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 106

    (45) logicOps -> exp AND exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 45 (logicOps -> exp AND exp .)
    AND             reduce using rule 45 (logicOps -> exp AND exp .)
    OR              reduce using rule 45 (logicOps -> exp AND exp .)
    RPAREN          reduce using rule 45 (logicOps -> exp AND exp .)
    COMMA           reduce using rule 45 (logicOps -> exp AND exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83

  ! TIMES           [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! PLUS            [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! EQUAL           [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! LT              [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! GT              [ reduce using rule 45 (logicOps -> exp AND exp .) ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 107

    (46) logicOps -> exp OR exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 46 (logicOps -> exp OR exp .)
    OR              reduce using rule 46 (logicOps -> exp OR exp .)
    RPAREN          reduce using rule 46 (logicOps -> exp OR exp .)
    COMMA           reduce using rule 46 (logicOps -> exp OR exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84

  ! TIMES           [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! PLUS            [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! EQUAL           [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! LT              [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! GT              [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! AND             [ reduce using rule 46 (logicOps -> exp OR exp .) ]
  ! OR              [ shift and go to state 85 ]


state 108

    (18) stmt -> vdecl ASSIGN exp . SEMICOLON
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       shift and go to state 119
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 109

    (20) stmt -> WHILE LPAREN exp . RPAREN stmt
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    RPAREN          shift and go to state 120
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 110

    (27) exp -> LPAREN exp RPAREN .

    SEMICOLON       reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 27 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 27 (exp -> LPAREN exp RPAREN .)


state 111

    (21) stmt -> IF LPAREN exp . RPAREN stmt
    (22) stmt -> IF LPAREN exp . RPAREN stmt ELSE stmt
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    RPAREN          shift and go to state 121
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 112

    (23) stmt -> PRINT exp SEMICOLON .

    RETURN          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    WHILE           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    IF              reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    PRINT           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    LBRACE          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    LPAREN          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    INT             reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    CINT            reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    FLOAT           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    BOOL            reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    VOID            reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    REF             reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    NOALIAS         reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    LBRACKET        reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    MINUS           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    NOT             reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    TRUE            reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    FALSE           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    LIT             reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    VARID           reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    ID              reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    RBRACE          reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)
    ELSE            reduce using rule 23 (stmt -> PRINT exp SEMICOLON .)


state 113

    (24) stmt -> PRINT slit SEMICOLON .

    RETURN          reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    IF              reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    PRINT           reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    LBRACE          reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    LPAREN          reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    INT             reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    CINT            reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    FLOAT           reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    BOOL            reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    VOID            reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    REF             reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    NOALIAS         reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    LBRACKET        reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    MINUS           reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    NOT             reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    TRUE            reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    FALSE           reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    LIT             reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    VARID           reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    ID              reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    RBRACE          reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)
    ELSE            reduce using rule 24 (stmt -> PRINT slit SEMICOLON .)


state 114

    (36) binop -> varid ASSIGN exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 36 (binop -> varid ASSIGN exp .)
    RPAREN          reduce using rule 36 (binop -> varid ASSIGN exp .)
    COMMA           reduce using rule 36 (binop -> varid ASSIGN exp .)
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! TIMES           [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! DIVIDE          [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! PLUS            [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! MINUS           [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! EQUAL           [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! LT              [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! GT              [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! AND             [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]
  ! OR              [ reduce using rule 36 (binop -> varid ASSIGN exp .) ]


state 115

    (32) exp -> globid LPAREN RPAREN .

    SEMICOLON       reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    TIMES           reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    DIVIDE          reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    PLUS            reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    MINUS           reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    EQUAL           reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    LT              reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    GT              reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    AND             reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    OR              reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    RPAREN          reduce using rule 32 (exp -> globid LPAREN RPAREN .)
    COMMA           reduce using rule 32 (exp -> globid LPAREN RPAREN .)


state 116

    (33) exp -> globid LPAREN exps . RPAREN

    RPAREN          shift and go to state 122


state 117

    (25) exps -> exp .
    (26) exps -> exp . COMMA exps
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    RPAREN          reduce using rule 25 (exps -> exp .)
    COMMA           shift and go to state 123
    TIMES           shift and go to state 77
    DIVIDE          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    EQUAL           shift and go to state 81
    LT              shift and go to state 82
    GT              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85


state 118

    (37) binop -> LBRACKET TYPE RBRACKET . exp
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 124
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 119

    (18) stmt -> vdecl ASSIGN exp SEMICOLON .

    RETURN          reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    IF              reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    PRINT           reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    LPAREN          reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    INT             reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    CINT            reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    FLOAT           reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    BOOL            reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    REF             reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    NOALIAS         reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    LBRACKET        reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    MINUS           reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    NOT             reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    TRUE            reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    FALSE           reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    LIT             reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    VARID           reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    ID              reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    RBRACE          reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 18 (stmt -> vdecl ASSIGN exp SEMICOLON .)


state 120

    (20) stmt -> WHILE LPAREN exp RPAREN . stmt
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl ASSIGN exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT slit SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE
    (66) vdecl -> . TYPE varid
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    RETURN          shift and go to state 48
    WHILE           shift and go to state 51
    IF              shift and go to state 53
    PRINT           shift and go to state 54
    LBRACE          shift and go to state 38
    LPAREN          shift and go to state 52
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 49
    stmt                           shift and go to state 125
    blk                            shift and go to state 47
    vdecl                          shift and go to state 50
    TYPE                           shift and go to state 28
    varid                          shift and go to state 55
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 121

    (21) stmt -> IF LPAREN exp RPAREN . stmt
    (22) stmt -> IF LPAREN exp RPAREN . stmt ELSE stmt
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl ASSIGN exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT slit SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE
    (66) vdecl -> . TYPE varid
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    RETURN          shift and go to state 48
    WHILE           shift and go to state 51
    IF              shift and go to state 53
    PRINT           shift and go to state 54
    LBRACE          shift and go to state 38
    LPAREN          shift and go to state 52
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 49
    stmt                           shift and go to state 126
    blk                            shift and go to state 47
    vdecl                          shift and go to state 50
    TYPE                           shift and go to state 28
    varid                          shift and go to state 55
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 122

    (33) exp -> globid LPAREN exps RPAREN .

    SEMICOLON       reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    TIMES           reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    DIVIDE          reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    PLUS            reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    MINUS           reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    EQUAL           reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    LT              reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    GT              reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    AND             reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    OR              reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    RPAREN          reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)
    COMMA           reduce using rule 33 (exp -> globid LPAREN exps RPAREN .)


state 123

    (26) exps -> exp COMMA . exps
    (25) exps -> . exp
    (26) exps -> . exp COMMA exps
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    LPAREN          shift and go to state 52
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 117
    exps                           shift and go to state 127
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    varid                          shift and go to state 55
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 124

    (37) binop -> LBRACKET TYPE RBRACKET exp .
    (38) arithOps -> exp . TIMES exp
    (39) arithOps -> exp . DIVIDE exp
    (40) arithOps -> exp . PLUS exp
    (41) arithOps -> exp . MINUS exp
    (42) logicOps -> exp . EQUAL exp
    (43) logicOps -> exp . LT exp
    (44) logicOps -> exp . GT exp
    (45) logicOps -> exp . AND exp
    (46) logicOps -> exp . OR exp

    SEMICOLON       reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    TIMES           reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    DIVIDE          reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    PLUS            reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    MINUS           reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    EQUAL           reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    LT              reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    GT              reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    AND             reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    OR              reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    RPAREN          reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)
    COMMA           reduce using rule 37 (binop -> LBRACKET TYPE RBRACKET exp .)

  ! TIMES           [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQUAL           [ shift and go to state 81 ]
  ! LT              [ shift and go to state 82 ]
  ! GT              [ shift and go to state 83 ]
  ! AND             [ shift and go to state 84 ]
  ! OR              [ shift and go to state 85 ]


state 125

    (20) stmt -> WHILE LPAREN exp RPAREN stmt .

    RETURN          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    WHILE           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    IF              reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    PRINT           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    LBRACE          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    LPAREN          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    INT             reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    CINT            reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    FLOAT           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    BOOL            reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    VOID            reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    REF             reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    NOALIAS         reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    LBRACKET        reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    MINUS           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    NOT             reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    TRUE            reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    FALSE           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    LIT             reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    VARID           reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    ID              reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    RBRACE          reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)
    ELSE            reduce using rule 20 (stmt -> WHILE LPAREN exp RPAREN stmt .)


state 126

    (21) stmt -> IF LPAREN exp RPAREN stmt .
    (22) stmt -> IF LPAREN exp RPAREN stmt . ELSE stmt

    RETURN          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    WHILE           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    IF              reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    PRINT           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    LBRACE          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    LPAREN          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    INT             reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    CINT            reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    FLOAT           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    BOOL            reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    VOID            reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    REF             reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    NOALIAS         reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    LBRACKET        reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    MINUS           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    NOT             reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    TRUE            reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    FALSE           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    LIT             reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    VARID           reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    ID              reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    RBRACE          reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .)
    ELSE            shift and go to state 128

  ! ELSE            [ reduce using rule 21 (stmt -> IF LPAREN exp RPAREN stmt .) ]


state 127

    (26) exps -> exp COMMA exps .

    RPAREN          reduce using rule 26 (exps -> exp COMMA exps .)


state 128

    (22) stmt -> IF LPAREN exp RPAREN stmt ELSE . stmt
    (15) stmt -> . blk
    (16) stmt -> . RETURN SEMICOLON
    (17) stmt -> . RETURN exp SEMICOLON
    (18) stmt -> . vdecl ASSIGN exp SEMICOLON
    (19) stmt -> . exp SEMICOLON
    (20) stmt -> . WHILE LPAREN exp RPAREN stmt
    (21) stmt -> . IF LPAREN exp RPAREN stmt
    (22) stmt -> . IF LPAREN exp RPAREN stmt ELSE stmt
    (23) stmt -> . PRINT exp SEMICOLON
    (24) stmt -> . PRINT slit SEMICOLON
    (11) blk -> . LBRACE RBRACE
    (12) blk -> . LBRACE stmts RBRACE
    (66) vdecl -> . TYPE varid
    (27) exp -> . LPAREN exp RPAREN
    (28) exp -> . binop
    (29) exp -> . uop
    (30) exp -> . lit
    (31) exp -> . varid
    (32) exp -> . globid LPAREN RPAREN
    (33) exp -> . globid LPAREN exps RPAREN
    (55) TYPE -> . INT
    (56) TYPE -> . CINT
    (57) TYPE -> . FLOAT
    (58) TYPE -> . BOOL
    (59) TYPE -> . VOID
    (60) TYPE -> . REF TYPE
    (61) TYPE -> . NOALIAS REF TYPE
    (34) binop -> . arithOps
    (35) binop -> . logicOps
    (36) binop -> . varid ASSIGN exp
    (37) binop -> . LBRACKET TYPE RBRACKET exp
    (47) uop -> . MINUS exp
    (48) uop -> . NOT exp
    (49) lit -> . TRUE
    (50) lit -> . FALSE
    (51) lit -> . LIT
    (53) varid -> . VARID
    (54) globid -> . ID
    (38) arithOps -> . exp TIMES exp
    (39) arithOps -> . exp DIVIDE exp
    (40) arithOps -> . exp PLUS exp
    (41) arithOps -> . exp MINUS exp
    (42) logicOps -> . exp EQUAL exp
    (43) logicOps -> . exp LT exp
    (44) logicOps -> . exp GT exp
    (45) logicOps -> . exp AND exp
    (46) logicOps -> . exp OR exp

    RETURN          shift and go to state 48
    WHILE           shift and go to state 51
    IF              shift and go to state 53
    PRINT           shift and go to state 54
    LBRACE          shift and go to state 38
    LPAREN          shift and go to state 52
    INT             shift and go to state 12
    CINT            shift and go to state 13
    FLOAT           shift and go to state 14
    BOOL            shift and go to state 15
    VOID            shift and go to state 16
    REF             shift and go to state 17
    NOALIAS         shift and go to state 18
    LBRACKET        shift and go to state 62
    MINUS           shift and go to state 63
    NOT             shift and go to state 64
    TRUE            shift and go to state 65
    FALSE           shift and go to state 66
    LIT             shift and go to state 67
    VARID           shift and go to state 36
    ID              shift and go to state 21

    exp                            shift and go to state 49
    stmt                           shift and go to state 129
    blk                            shift and go to state 47
    vdecl                          shift and go to state 50
    TYPE                           shift and go to state 28
    varid                          shift and go to state 55
    binop                          shift and go to state 56
    uop                            shift and go to state 57
    lit                            shift and go to state 58
    globid                         shift and go to state 59
    arithOps                       shift and go to state 60
    logicOps                       shift and go to state 61

state 129

    (22) stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .

    RETURN          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    IF              reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    PRINT           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    INT             reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    CINT            reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    BOOL            reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    VOID            reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    REF             reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    NOALIAS         reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    LBRACKET        reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    MINUS           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    NOT             reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    LIT             reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    VARID           reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    ID              reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 22 (stmt -> IF LPAREN exp RPAREN stmt ELSE stmt .)

