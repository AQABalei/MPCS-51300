Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    Comment
    LSquareBracket
    RSquareBracket
    newline

Grammar

Rule 0     S' -> prog
Rule 1     prog -> funcs
Rule 2     prog -> externs funcs
Rule 3     externs -> extern
Rule 4     externs -> extern externs
Rule 5     funcs -> func
Rule 6     funcs -> func funcs
Rule 7     extern -> EXTERN TYPE GLOBID LParen RParen Semicolon
Rule 8     extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon
Rule 9     func -> DEF TYPE GLOBID LParen RParen blk
Rule 10    func -> DEF TYPE GLOBID LParen vdecls RParen blk
Rule 11    blk -> LBracket stmts RBracket
Rule 12    blk -> LBracket RBracket
Rule 13    stmts -> stmt
Rule 14    stmts -> stmt stmts
Rule 15    stmt -> blk
Rule 16    stmt -> Return Semicolon
Rule 17    stmt -> Return exp Semicolon
Rule 18    stmt -> vdecl Equal exp Semicolon
Rule 19    stmt -> exp Semicolon
Rule 20    stmt -> While LParen exp RParen stmt
Rule 21    stmt -> If LParen exp RParen stmt
Rule 22    stmt -> If LParen exp RParen stmt Else stmt
Rule 23    stmt -> Print exp Semicolon
Rule 24    exps -> exp
Rule 25    exps -> exp COMMA exps
Rule 26    exp -> LParen exp RParen
Rule 27    exp -> lit
Rule 28    exp -> slit
Rule 29    exp -> binop
Rule 30    exp -> uop
Rule 31    exp -> var
Rule 32    exp -> GLOBID expWrapper
Rule 33    expWrapper -> LParen RParen
Rule 34    expWrapper -> LParen exps RParen
Rule 35    binop -> exp Multiply exp
Rule 36    binop -> exp PLUS exp
Rule 37    binop -> exp Divide exp
Rule 38    binop -> exp Minus exp
Rule 39    binop -> var Equal exp
Rule 40    binop -> exp Equality exp
Rule 41    binop -> exp lessThan exp
Rule 42    binop -> exp greaterThan exp
Rule 43    binop -> exp logicalAnd exp
Rule 44    binop -> exp logicalOr exp
Rule 45    uop -> Minus exp
Rule 46    uop -> logicalNegation exp
Rule 47    vdecls -> vdecl COMMA vdecls
Rule 48    vdecls -> vdecl
Rule 49    vdecl -> TYPE var
Rule 50    tdecls -> TYPE
Rule 51    tdecls -> TYPE COMMA tdecls
Rule 52    TYPE -> int
Rule 53    TYPE -> float
Rule 54    TYPE -> cint
Rule 55    TYPE -> sfloat
Rule 56    TYPE -> void
Rule 57    TYPE -> ref TYPE
Rule 58    TYPE -> noalias ref TYPE

Terminals, with rules where they appear

COMMA                : 25 47 51
Comment              : 
DEF                  : 9 10
Divide               : 37
EXTERN               : 7 8
Else                 : 22
Equal                : 18 39
Equality             : 40
GLOBID               : 7 8 9 10 32
If                   : 21 22
LBracket             : 11 12
LParen               : 7 8 9 10 20 21 22 26 33 34
LSquareBracket       : 
Minus                : 38 45
Multiply             : 35
PLUS                 : 36
Print                : 23
RBracket             : 11 12
RParen               : 7 8 9 10 20 21 22 26 33 34
RSquareBracket       : 
Return               : 16 17
Semicolon            : 7 8 16 17 18 19 23
While                : 20
cint                 : 54
error                : 
float                : 53
greaterThan          : 42
int                  : 52
lessThan             : 41
lit                  : 27
logicalAnd           : 43
logicalNegation      : 46
logicalOr            : 44
newline              : 
noalias              : 58
ref                  : 57 58
sfloat               : 55
slit                 : 28
var                  : 31 39 49
void                 : 56

Nonterminals, with rules where they appear

TYPE                 : 7 8 9 10 49 50 51 57 58
binop                : 29
blk                  : 9 10 15
exp                  : 17 18 19 20 21 22 23 24 25 26 35 35 36 36 37 37 38 38 39 40 40 41 41 42 42 43 43 44 44 45 46
expWrapper           : 32
exps                 : 25 34
extern               : 3 4
externs              : 2 4
func                 : 5 6
funcs                : 1 2 6
prog                 : 0
stmt                 : 13 14 20 21 22 22
stmts                : 11 14
tdecls               : 8 51
uop                  : 30
vdecl                : 18 47 48
vdecls               : 10 47

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . funcs
    (2) prog -> . externs funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             shift and go to state 6
    EXTERN          shift and go to state 7

    prog                           shift and go to state 1
    funcs                          shift and go to state 2
    externs                        shift and go to state 3
    func                           shift and go to state 4
    extern                         shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> funcs .

    $end            reduce using rule 1 (prog -> funcs .)


state 3

    (2) prog -> externs . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    DEF             shift and go to state 6

    funcs                          shift and go to state 8
    func                           shift and go to state 4

state 4

    (5) funcs -> func .
    (6) funcs -> func . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    $end            reduce using rule 5 (funcs -> func .)
    DEF             shift and go to state 6

    func                           shift and go to state 4
    funcs                          shift and go to state 9

state 5

    (3) externs -> extern .
    (4) externs -> extern . externs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             reduce using rule 3 (externs -> extern .)
    EXTERN          shift and go to state 7

    extern                         shift and go to state 5
    externs                        shift and go to state 10

state 6

    (9) func -> DEF . TYPE GLOBID LParen RParen blk
    (10) func -> DEF . TYPE GLOBID LParen vdecls RParen blk
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 11

state 7

    (7) extern -> EXTERN . TYPE GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN . TYPE GLOBID LParen tdecls RParen Semicolon
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 19

state 8

    (2) prog -> externs funcs .

    $end            reduce using rule 2 (prog -> externs funcs .)


state 9

    (6) funcs -> func funcs .

    $end            reduce using rule 6 (funcs -> func funcs .)


state 10

    (4) externs -> extern externs .

    DEF             reduce using rule 4 (externs -> extern externs .)


state 11

    (9) func -> DEF TYPE . GLOBID LParen RParen blk
    (10) func -> DEF TYPE . GLOBID LParen vdecls RParen blk

    GLOBID          shift and go to state 20


state 12

    (52) TYPE -> int .

    GLOBID          reduce using rule 52 (TYPE -> int .)
    var             reduce using rule 52 (TYPE -> int .)
    COMMA           reduce using rule 52 (TYPE -> int .)
    RParen          reduce using rule 52 (TYPE -> int .)


state 13

    (53) TYPE -> float .

    GLOBID          reduce using rule 53 (TYPE -> float .)
    var             reduce using rule 53 (TYPE -> float .)
    COMMA           reduce using rule 53 (TYPE -> float .)
    RParen          reduce using rule 53 (TYPE -> float .)


state 14

    (54) TYPE -> cint .

    GLOBID          reduce using rule 54 (TYPE -> cint .)
    var             reduce using rule 54 (TYPE -> cint .)
    COMMA           reduce using rule 54 (TYPE -> cint .)
    RParen          reduce using rule 54 (TYPE -> cint .)


state 15

    (55) TYPE -> sfloat .

    GLOBID          reduce using rule 55 (TYPE -> sfloat .)
    var             reduce using rule 55 (TYPE -> sfloat .)
    COMMA           reduce using rule 55 (TYPE -> sfloat .)
    RParen          reduce using rule 55 (TYPE -> sfloat .)


state 16

    (56) TYPE -> void .

    GLOBID          reduce using rule 56 (TYPE -> void .)
    var             reduce using rule 56 (TYPE -> void .)
    COMMA           reduce using rule 56 (TYPE -> void .)
    RParen          reduce using rule 56 (TYPE -> void .)


state 17

    (57) TYPE -> ref . TYPE
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 21

state 18

    (58) TYPE -> noalias . ref TYPE

    ref             shift and go to state 22


state 19

    (7) extern -> EXTERN TYPE . GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN TYPE . GLOBID LParen tdecls RParen Semicolon

    GLOBID          shift and go to state 23


state 20

    (9) func -> DEF TYPE GLOBID . LParen RParen blk
    (10) func -> DEF TYPE GLOBID . LParen vdecls RParen blk

    LParen          shift and go to state 24


state 21

    (57) TYPE -> ref TYPE .

    GLOBID          reduce using rule 57 (TYPE -> ref TYPE .)
    var             reduce using rule 57 (TYPE -> ref TYPE .)
    COMMA           reduce using rule 57 (TYPE -> ref TYPE .)
    RParen          reduce using rule 57 (TYPE -> ref TYPE .)


state 22

    (58) TYPE -> noalias ref . TYPE
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 25

state 23

    (7) extern -> EXTERN TYPE GLOBID . LParen RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID . LParen tdecls RParen Semicolon

    LParen          shift and go to state 26


state 24

    (9) func -> DEF TYPE GLOBID LParen . RParen blk
    (10) func -> DEF TYPE GLOBID LParen . vdecls RParen blk
    (47) vdecls -> . vdecl COMMA vdecls
    (48) vdecls -> . vdecl
    (49) vdecl -> . TYPE var
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 28
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 27
    vdecls                         shift and go to state 29
    vdecl                          shift and go to state 30

state 25

    (58) TYPE -> noalias ref TYPE .

    GLOBID          reduce using rule 58 (TYPE -> noalias ref TYPE .)
    var             reduce using rule 58 (TYPE -> noalias ref TYPE .)
    COMMA           reduce using rule 58 (TYPE -> noalias ref TYPE .)
    RParen          reduce using rule 58 (TYPE -> noalias ref TYPE .)


state 26

    (7) extern -> EXTERN TYPE GLOBID LParen . RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID LParen . tdecls RParen Semicolon
    (50) tdecls -> . TYPE
    (51) tdecls -> . TYPE COMMA tdecls
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 32
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 31
    tdecls                         shift and go to state 33

state 27

    (49) vdecl -> TYPE . var

    var             shift and go to state 34


state 28

    (9) func -> DEF TYPE GLOBID LParen RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 36

    blk                            shift and go to state 35

state 29

    (10) func -> DEF TYPE GLOBID LParen vdecls . RParen blk

    RParen          shift and go to state 37


state 30

    (47) vdecls -> vdecl . COMMA vdecls
    (48) vdecls -> vdecl .

    COMMA           shift and go to state 38
    RParen          reduce using rule 48 (vdecls -> vdecl .)


state 31

    (50) tdecls -> TYPE .
    (51) tdecls -> TYPE . COMMA tdecls

    RParen          reduce using rule 50 (tdecls -> TYPE .)
    COMMA           shift and go to state 39


state 32

    (7) extern -> EXTERN TYPE GLOBID LParen RParen . Semicolon

    Semicolon       shift and go to state 40


state 33

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls . RParen Semicolon

    RParen          shift and go to state 41


state 34

    (49) vdecl -> TYPE var .

    COMMA           reduce using rule 49 (vdecl -> TYPE var .)
    RParen          reduce using rule 49 (vdecl -> TYPE var .)
    Equal           reduce using rule 49 (vdecl -> TYPE var .)


state 35

    (9) func -> DEF TYPE GLOBID LParen RParen blk .

    DEF             reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)
    $end            reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)


state 36

    (11) blk -> LBracket . stmts RBracket
    (12) blk -> LBracket . RBracket
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (49) vdecl -> . TYPE var
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    RBracket        shift and go to state 43
    Return          shift and go to state 46
    While           shift and go to state 49
    If              shift and go to state 51
    Print           shift and go to state 52
    LBracket        shift and go to state 36
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    stmts                          shift and go to state 42
    stmt                           shift and go to state 44
    blk                            shift and go to state 45
    exp                            shift and go to state 47
    vdecl                          shift and go to state 48
    TYPE                           shift and go to state 27
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 37

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 36

    blk                            shift and go to state 61

state 38

    (47) vdecls -> vdecl COMMA . vdecls
    (47) vdecls -> . vdecl COMMA vdecls
    (48) vdecls -> . vdecl
    (49) vdecl -> . TYPE var
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    vdecl                          shift and go to state 30
    vdecls                         shift and go to state 62
    TYPE                           shift and go to state 27

state 39

    (51) tdecls -> TYPE COMMA . tdecls
    (50) tdecls -> . TYPE
    (51) tdecls -> . TYPE COMMA tdecls
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18

    TYPE                           shift and go to state 31
    tdecls                         shift and go to state 63

state 40

    (7) extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .

    EXTERN          reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)
    DEF             reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)


state 41

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen . Semicolon

    Semicolon       shift and go to state 64


state 42

    (11) blk -> LBracket stmts . RBracket

    RBracket        shift and go to state 65


state 43

    (12) blk -> LBracket RBracket .

    DEF             reduce using rule 12 (blk -> LBracket RBracket .)
    $end            reduce using rule 12 (blk -> LBracket RBracket .)
    Return          reduce using rule 12 (blk -> LBracket RBracket .)
    While           reduce using rule 12 (blk -> LBracket RBracket .)
    If              reduce using rule 12 (blk -> LBracket RBracket .)
    Print           reduce using rule 12 (blk -> LBracket RBracket .)
    LBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    LParen          reduce using rule 12 (blk -> LBracket RBracket .)
    lit             reduce using rule 12 (blk -> LBracket RBracket .)
    slit            reduce using rule 12 (blk -> LBracket RBracket .)
    var             reduce using rule 12 (blk -> LBracket RBracket .)
    GLOBID          reduce using rule 12 (blk -> LBracket RBracket .)
    int             reduce using rule 12 (blk -> LBracket RBracket .)
    float           reduce using rule 12 (blk -> LBracket RBracket .)
    cint            reduce using rule 12 (blk -> LBracket RBracket .)
    sfloat          reduce using rule 12 (blk -> LBracket RBracket .)
    void            reduce using rule 12 (blk -> LBracket RBracket .)
    ref             reduce using rule 12 (blk -> LBracket RBracket .)
    noalias         reduce using rule 12 (blk -> LBracket RBracket .)
    Minus           reduce using rule 12 (blk -> LBracket RBracket .)
    logicalNegation reduce using rule 12 (blk -> LBracket RBracket .)
    RBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    Else            reduce using rule 12 (blk -> LBracket RBracket .)


state 44

    (13) stmts -> stmt .
    (14) stmts -> stmt . stmts
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (49) vdecl -> . TYPE var
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    RBracket        reduce using rule 13 (stmts -> stmt .)
    Return          shift and go to state 46
    While           shift and go to state 49
    If              shift and go to state 51
    Print           shift and go to state 52
    LBracket        shift and go to state 36
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    stmt                           shift and go to state 44
    stmts                          shift and go to state 66
    blk                            shift and go to state 45
    exp                            shift and go to state 47
    vdecl                          shift and go to state 48
    TYPE                           shift and go to state 27
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 45

    (15) stmt -> blk .

    Return          reduce using rule 15 (stmt -> blk .)
    While           reduce using rule 15 (stmt -> blk .)
    If              reduce using rule 15 (stmt -> blk .)
    Print           reduce using rule 15 (stmt -> blk .)
    LBracket        reduce using rule 15 (stmt -> blk .)
    LParen          reduce using rule 15 (stmt -> blk .)
    lit             reduce using rule 15 (stmt -> blk .)
    slit            reduce using rule 15 (stmt -> blk .)
    var             reduce using rule 15 (stmt -> blk .)
    GLOBID          reduce using rule 15 (stmt -> blk .)
    int             reduce using rule 15 (stmt -> blk .)
    float           reduce using rule 15 (stmt -> blk .)
    cint            reduce using rule 15 (stmt -> blk .)
    sfloat          reduce using rule 15 (stmt -> blk .)
    void            reduce using rule 15 (stmt -> blk .)
    ref             reduce using rule 15 (stmt -> blk .)
    noalias         reduce using rule 15 (stmt -> blk .)
    Minus           reduce using rule 15 (stmt -> blk .)
    logicalNegation reduce using rule 15 (stmt -> blk .)
    RBracket        reduce using rule 15 (stmt -> blk .)
    Else            reduce using rule 15 (stmt -> blk .)


state 46

    (16) stmt -> Return . Semicolon
    (17) stmt -> Return . exp Semicolon
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    Semicolon       shift and go to state 67
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 68
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 47

    (19) stmt -> exp . Semicolon
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       shift and go to state 69
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 48

    (18) stmt -> vdecl . Equal exp Semicolon

    Equal           shift and go to state 79


state 49

    (20) stmt -> While . LParen exp RParen stmt

    LParen          shift and go to state 80


state 50

    (26) exp -> LParen . exp RParen
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 81
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 51

    (21) stmt -> If . LParen exp RParen stmt
    (22) stmt -> If . LParen exp RParen stmt Else stmt

    LParen          shift and go to state 82


state 52

    (23) stmt -> Print . exp Semicolon
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 83
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 53

    (31) exp -> var .
    (39) binop -> var . Equal exp

    Semicolon       reduce using rule 31 (exp -> var .)
    Multiply        reduce using rule 31 (exp -> var .)
    PLUS            reduce using rule 31 (exp -> var .)
    Divide          reduce using rule 31 (exp -> var .)
    Minus           reduce using rule 31 (exp -> var .)
    Equality        reduce using rule 31 (exp -> var .)
    lessThan        reduce using rule 31 (exp -> var .)
    greaterThan     reduce using rule 31 (exp -> var .)
    logicalAnd      reduce using rule 31 (exp -> var .)
    logicalOr       reduce using rule 31 (exp -> var .)
    RParen          reduce using rule 31 (exp -> var .)
    COMMA           reduce using rule 31 (exp -> var .)
    Equal           shift and go to state 84


state 54

    (27) exp -> lit .

    Semicolon       reduce using rule 27 (exp -> lit .)
    Multiply        reduce using rule 27 (exp -> lit .)
    PLUS            reduce using rule 27 (exp -> lit .)
    Divide          reduce using rule 27 (exp -> lit .)
    Minus           reduce using rule 27 (exp -> lit .)
    Equality        reduce using rule 27 (exp -> lit .)
    lessThan        reduce using rule 27 (exp -> lit .)
    greaterThan     reduce using rule 27 (exp -> lit .)
    logicalAnd      reduce using rule 27 (exp -> lit .)
    logicalOr       reduce using rule 27 (exp -> lit .)
    RParen          reduce using rule 27 (exp -> lit .)
    COMMA           reduce using rule 27 (exp -> lit .)


state 55

    (28) exp -> slit .

    Semicolon       reduce using rule 28 (exp -> slit .)
    Multiply        reduce using rule 28 (exp -> slit .)
    PLUS            reduce using rule 28 (exp -> slit .)
    Divide          reduce using rule 28 (exp -> slit .)
    Minus           reduce using rule 28 (exp -> slit .)
    Equality        reduce using rule 28 (exp -> slit .)
    lessThan        reduce using rule 28 (exp -> slit .)
    greaterThan     reduce using rule 28 (exp -> slit .)
    logicalAnd      reduce using rule 28 (exp -> slit .)
    logicalOr       reduce using rule 28 (exp -> slit .)
    RParen          reduce using rule 28 (exp -> slit .)
    COMMA           reduce using rule 28 (exp -> slit .)


state 56

    (29) exp -> binop .

    Semicolon       reduce using rule 29 (exp -> binop .)
    Multiply        reduce using rule 29 (exp -> binop .)
    PLUS            reduce using rule 29 (exp -> binop .)
    Divide          reduce using rule 29 (exp -> binop .)
    Minus           reduce using rule 29 (exp -> binop .)
    Equality        reduce using rule 29 (exp -> binop .)
    lessThan        reduce using rule 29 (exp -> binop .)
    greaterThan     reduce using rule 29 (exp -> binop .)
    logicalAnd      reduce using rule 29 (exp -> binop .)
    logicalOr       reduce using rule 29 (exp -> binop .)
    RParen          reduce using rule 29 (exp -> binop .)
    COMMA           reduce using rule 29 (exp -> binop .)


state 57

    (30) exp -> uop .

    Semicolon       reduce using rule 30 (exp -> uop .)
    Multiply        reduce using rule 30 (exp -> uop .)
    PLUS            reduce using rule 30 (exp -> uop .)
    Divide          reduce using rule 30 (exp -> uop .)
    Minus           reduce using rule 30 (exp -> uop .)
    Equality        reduce using rule 30 (exp -> uop .)
    lessThan        reduce using rule 30 (exp -> uop .)
    greaterThan     reduce using rule 30 (exp -> uop .)
    logicalAnd      reduce using rule 30 (exp -> uop .)
    logicalOr       reduce using rule 30 (exp -> uop .)
    RParen          reduce using rule 30 (exp -> uop .)
    COMMA           reduce using rule 30 (exp -> uop .)


state 58

    (32) exp -> GLOBID . expWrapper
    (33) expWrapper -> . LParen RParen
    (34) expWrapper -> . LParen exps RParen

    LParen          shift and go to state 86

    expWrapper                     shift and go to state 85

state 59

    (45) uop -> Minus . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 87
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 60

    (46) uop -> logicalNegation . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 88
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 61

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen blk .

    DEF             reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)
    $end            reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)


state 62

    (47) vdecls -> vdecl COMMA vdecls .

    RParen          reduce using rule 47 (vdecls -> vdecl COMMA vdecls .)


state 63

    (51) tdecls -> TYPE COMMA tdecls .

    RParen          reduce using rule 51 (tdecls -> TYPE COMMA tdecls .)


state 64

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .

    EXTERN          reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)
    DEF             reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)


state 65

    (11) blk -> LBracket stmts RBracket .

    DEF             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    $end            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Return          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    While           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    If              reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Print           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LParen          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    lit             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    slit            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    var             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    GLOBID          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    int             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    float           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    cint            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    sfloat          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    void            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    ref             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    noalias         reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Minus           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    logicalNegation reduce using rule 11 (blk -> LBracket stmts RBracket .)
    RBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Else            reduce using rule 11 (blk -> LBracket stmts RBracket .)


state 66

    (14) stmts -> stmt stmts .

    RBracket        reduce using rule 14 (stmts -> stmt stmts .)


state 67

    (16) stmt -> Return Semicolon .

    Return          reduce using rule 16 (stmt -> Return Semicolon .)
    While           reduce using rule 16 (stmt -> Return Semicolon .)
    If              reduce using rule 16 (stmt -> Return Semicolon .)
    Print           reduce using rule 16 (stmt -> Return Semicolon .)
    LBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    LParen          reduce using rule 16 (stmt -> Return Semicolon .)
    lit             reduce using rule 16 (stmt -> Return Semicolon .)
    slit            reduce using rule 16 (stmt -> Return Semicolon .)
    var             reduce using rule 16 (stmt -> Return Semicolon .)
    GLOBID          reduce using rule 16 (stmt -> Return Semicolon .)
    int             reduce using rule 16 (stmt -> Return Semicolon .)
    float           reduce using rule 16 (stmt -> Return Semicolon .)
    cint            reduce using rule 16 (stmt -> Return Semicolon .)
    sfloat          reduce using rule 16 (stmt -> Return Semicolon .)
    void            reduce using rule 16 (stmt -> Return Semicolon .)
    ref             reduce using rule 16 (stmt -> Return Semicolon .)
    noalias         reduce using rule 16 (stmt -> Return Semicolon .)
    Minus           reduce using rule 16 (stmt -> Return Semicolon .)
    logicalNegation reduce using rule 16 (stmt -> Return Semicolon .)
    RBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    Else            reduce using rule 16 (stmt -> Return Semicolon .)


state 68

    (17) stmt -> Return exp . Semicolon
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       shift and go to state 89
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 69

    (19) stmt -> exp Semicolon .

    Return          reduce using rule 19 (stmt -> exp Semicolon .)
    While           reduce using rule 19 (stmt -> exp Semicolon .)
    If              reduce using rule 19 (stmt -> exp Semicolon .)
    Print           reduce using rule 19 (stmt -> exp Semicolon .)
    LBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    LParen          reduce using rule 19 (stmt -> exp Semicolon .)
    lit             reduce using rule 19 (stmt -> exp Semicolon .)
    slit            reduce using rule 19 (stmt -> exp Semicolon .)
    var             reduce using rule 19 (stmt -> exp Semicolon .)
    GLOBID          reduce using rule 19 (stmt -> exp Semicolon .)
    int             reduce using rule 19 (stmt -> exp Semicolon .)
    float           reduce using rule 19 (stmt -> exp Semicolon .)
    cint            reduce using rule 19 (stmt -> exp Semicolon .)
    sfloat          reduce using rule 19 (stmt -> exp Semicolon .)
    void            reduce using rule 19 (stmt -> exp Semicolon .)
    ref             reduce using rule 19 (stmt -> exp Semicolon .)
    noalias         reduce using rule 19 (stmt -> exp Semicolon .)
    Minus           reduce using rule 19 (stmt -> exp Semicolon .)
    logicalNegation reduce using rule 19 (stmt -> exp Semicolon .)
    RBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    Else            reduce using rule 19 (stmt -> exp Semicolon .)


state 70

    (35) binop -> exp Multiply . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 90
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 71

    (36) binop -> exp PLUS . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 91
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 72

    (37) binop -> exp Divide . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 92
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 73

    (38) binop -> exp Minus . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 93
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 74

    (40) binop -> exp Equality . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 94
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 75

    (41) binop -> exp lessThan . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 95
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 76

    (42) binop -> exp greaterThan . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 96
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 77

    (43) binop -> exp logicalAnd . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 97
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 78

    (44) binop -> exp logicalOr . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 98
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 79

    (18) stmt -> vdecl Equal . exp Semicolon
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 99
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 80

    (20) stmt -> While LParen . exp RParen stmt
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 100
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 81

    (26) exp -> LParen exp . RParen
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    RParen          shift and go to state 101
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 82

    (21) stmt -> If LParen . exp RParen stmt
    (22) stmt -> If LParen . exp RParen stmt Else stmt
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 102
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 83

    (23) stmt -> Print exp . Semicolon
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       shift and go to state 103
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 84

    (39) binop -> var Equal . exp
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 104
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 85

    (32) exp -> GLOBID expWrapper .

    Semicolon       reduce using rule 32 (exp -> GLOBID expWrapper .)
    Multiply        reduce using rule 32 (exp -> GLOBID expWrapper .)
    PLUS            reduce using rule 32 (exp -> GLOBID expWrapper .)
    Divide          reduce using rule 32 (exp -> GLOBID expWrapper .)
    Minus           reduce using rule 32 (exp -> GLOBID expWrapper .)
    Equality        reduce using rule 32 (exp -> GLOBID expWrapper .)
    lessThan        reduce using rule 32 (exp -> GLOBID expWrapper .)
    greaterThan     reduce using rule 32 (exp -> GLOBID expWrapper .)
    logicalAnd      reduce using rule 32 (exp -> GLOBID expWrapper .)
    logicalOr       reduce using rule 32 (exp -> GLOBID expWrapper .)
    RParen          reduce using rule 32 (exp -> GLOBID expWrapper .)
    COMMA           reduce using rule 32 (exp -> GLOBID expWrapper .)


state 86

    (33) expWrapper -> LParen . RParen
    (34) expWrapper -> LParen . exps RParen
    (24) exps -> . exp
    (25) exps -> . exp COMMA exps
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    RParen          shift and go to state 105
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exps                           shift and go to state 106
    exp                            shift and go to state 107
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 87

    (45) uop -> Minus exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 45 (uop -> Minus exp .)
    Multiply        reduce using rule 45 (uop -> Minus exp .)
    PLUS            reduce using rule 45 (uop -> Minus exp .)
    Divide          reduce using rule 45 (uop -> Minus exp .)
    Minus           reduce using rule 45 (uop -> Minus exp .)
    Equality        reduce using rule 45 (uop -> Minus exp .)
    lessThan        reduce using rule 45 (uop -> Minus exp .)
    greaterThan     reduce using rule 45 (uop -> Minus exp .)
    logicalAnd      reduce using rule 45 (uop -> Minus exp .)
    logicalOr       reduce using rule 45 (uop -> Minus exp .)
    RParen          reduce using rule 45 (uop -> Minus exp .)
    COMMA           reduce using rule 45 (uop -> Minus exp .)

  ! Multiply        [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! Divide          [ shift and go to state 72 ]
  ! Minus           [ shift and go to state 73 ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 88

    (46) uop -> logicalNegation exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 46 (uop -> logicalNegation exp .)
    Multiply        reduce using rule 46 (uop -> logicalNegation exp .)
    PLUS            reduce using rule 46 (uop -> logicalNegation exp .)
    Divide          reduce using rule 46 (uop -> logicalNegation exp .)
    Minus           reduce using rule 46 (uop -> logicalNegation exp .)
    Equality        reduce using rule 46 (uop -> logicalNegation exp .)
    lessThan        reduce using rule 46 (uop -> logicalNegation exp .)
    greaterThan     reduce using rule 46 (uop -> logicalNegation exp .)
    logicalAnd      reduce using rule 46 (uop -> logicalNegation exp .)
    logicalOr       reduce using rule 46 (uop -> logicalNegation exp .)
    RParen          reduce using rule 46 (uop -> logicalNegation exp .)
    COMMA           reduce using rule 46 (uop -> logicalNegation exp .)

  ! Multiply        [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! Divide          [ shift and go to state 72 ]
  ! Minus           [ shift and go to state 73 ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 89

    (17) stmt -> Return exp Semicolon .

    Return          reduce using rule 17 (stmt -> Return exp Semicolon .)
    While           reduce using rule 17 (stmt -> Return exp Semicolon .)
    If              reduce using rule 17 (stmt -> Return exp Semicolon .)
    Print           reduce using rule 17 (stmt -> Return exp Semicolon .)
    LBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    LParen          reduce using rule 17 (stmt -> Return exp Semicolon .)
    lit             reduce using rule 17 (stmt -> Return exp Semicolon .)
    slit            reduce using rule 17 (stmt -> Return exp Semicolon .)
    var             reduce using rule 17 (stmt -> Return exp Semicolon .)
    GLOBID          reduce using rule 17 (stmt -> Return exp Semicolon .)
    int             reduce using rule 17 (stmt -> Return exp Semicolon .)
    float           reduce using rule 17 (stmt -> Return exp Semicolon .)
    cint            reduce using rule 17 (stmt -> Return exp Semicolon .)
    sfloat          reduce using rule 17 (stmt -> Return exp Semicolon .)
    void            reduce using rule 17 (stmt -> Return exp Semicolon .)
    ref             reduce using rule 17 (stmt -> Return exp Semicolon .)
    noalias         reduce using rule 17 (stmt -> Return exp Semicolon .)
    Minus           reduce using rule 17 (stmt -> Return exp Semicolon .)
    logicalNegation reduce using rule 17 (stmt -> Return exp Semicolon .)
    RBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    Else            reduce using rule 17 (stmt -> Return exp Semicolon .)


state 90

    (35) binop -> exp Multiply exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 35 (binop -> exp Multiply exp .)
    Multiply        reduce using rule 35 (binop -> exp Multiply exp .)
    PLUS            reduce using rule 35 (binop -> exp Multiply exp .)
    Divide          reduce using rule 35 (binop -> exp Multiply exp .)
    Minus           reduce using rule 35 (binop -> exp Multiply exp .)
    Equality        reduce using rule 35 (binop -> exp Multiply exp .)
    lessThan        reduce using rule 35 (binop -> exp Multiply exp .)
    greaterThan     reduce using rule 35 (binop -> exp Multiply exp .)
    logicalAnd      reduce using rule 35 (binop -> exp Multiply exp .)
    logicalOr       reduce using rule 35 (binop -> exp Multiply exp .)
    RParen          reduce using rule 35 (binop -> exp Multiply exp .)
    COMMA           reduce using rule 35 (binop -> exp Multiply exp .)

  ! Multiply        [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! Divide          [ shift and go to state 72 ]
  ! Minus           [ shift and go to state 73 ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 91

    (36) binop -> exp PLUS exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 36 (binop -> exp PLUS exp .)
    PLUS            reduce using rule 36 (binop -> exp PLUS exp .)
    Minus           reduce using rule 36 (binop -> exp PLUS exp .)
    Equality        reduce using rule 36 (binop -> exp PLUS exp .)
    lessThan        reduce using rule 36 (binop -> exp PLUS exp .)
    greaterThan     reduce using rule 36 (binop -> exp PLUS exp .)
    logicalAnd      reduce using rule 36 (binop -> exp PLUS exp .)
    logicalOr       reduce using rule 36 (binop -> exp PLUS exp .)
    RParen          reduce using rule 36 (binop -> exp PLUS exp .)
    COMMA           reduce using rule 36 (binop -> exp PLUS exp .)
    Multiply        shift and go to state 70
    Divide          shift and go to state 72

  ! Multiply        [ reduce using rule 36 (binop -> exp PLUS exp .) ]
  ! Divide          [ reduce using rule 36 (binop -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 71 ]
  ! Minus           [ shift and go to state 73 ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 92

    (37) binop -> exp Divide exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 37 (binop -> exp Divide exp .)
    Multiply        reduce using rule 37 (binop -> exp Divide exp .)
    PLUS            reduce using rule 37 (binop -> exp Divide exp .)
    Divide          reduce using rule 37 (binop -> exp Divide exp .)
    Minus           reduce using rule 37 (binop -> exp Divide exp .)
    Equality        reduce using rule 37 (binop -> exp Divide exp .)
    lessThan        reduce using rule 37 (binop -> exp Divide exp .)
    greaterThan     reduce using rule 37 (binop -> exp Divide exp .)
    logicalAnd      reduce using rule 37 (binop -> exp Divide exp .)
    logicalOr       reduce using rule 37 (binop -> exp Divide exp .)
    RParen          reduce using rule 37 (binop -> exp Divide exp .)
    COMMA           reduce using rule 37 (binop -> exp Divide exp .)

  ! Multiply        [ shift and go to state 70 ]
  ! PLUS            [ shift and go to state 71 ]
  ! Divide          [ shift and go to state 72 ]
  ! Minus           [ shift and go to state 73 ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 93

    (38) binop -> exp Minus exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 38 (binop -> exp Minus exp .)
    PLUS            reduce using rule 38 (binop -> exp Minus exp .)
    Minus           reduce using rule 38 (binop -> exp Minus exp .)
    Equality        reduce using rule 38 (binop -> exp Minus exp .)
    lessThan        reduce using rule 38 (binop -> exp Minus exp .)
    greaterThan     reduce using rule 38 (binop -> exp Minus exp .)
    logicalAnd      reduce using rule 38 (binop -> exp Minus exp .)
    logicalOr       reduce using rule 38 (binop -> exp Minus exp .)
    RParen          reduce using rule 38 (binop -> exp Minus exp .)
    COMMA           reduce using rule 38 (binop -> exp Minus exp .)
    Multiply        shift and go to state 70
    Divide          shift and go to state 72

  ! Multiply        [ reduce using rule 38 (binop -> exp Minus exp .) ]
  ! Divide          [ reduce using rule 38 (binop -> exp Minus exp .) ]
  ! PLUS            [ shift and go to state 71 ]
  ! Minus           [ shift and go to state 73 ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 94

    (40) binop -> exp Equality exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 40 (binop -> exp Equality exp .)
    Equality        reduce using rule 40 (binop -> exp Equality exp .)
    logicalAnd      reduce using rule 40 (binop -> exp Equality exp .)
    logicalOr       reduce using rule 40 (binop -> exp Equality exp .)
    RParen          reduce using rule 40 (binop -> exp Equality exp .)
    COMMA           reduce using rule 40 (binop -> exp Equality exp .)
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76

  ! Multiply        [ reduce using rule 40 (binop -> exp Equality exp .) ]
  ! PLUS            [ reduce using rule 40 (binop -> exp Equality exp .) ]
  ! Divide          [ reduce using rule 40 (binop -> exp Equality exp .) ]
  ! Minus           [ reduce using rule 40 (binop -> exp Equality exp .) ]
  ! lessThan        [ reduce using rule 40 (binop -> exp Equality exp .) ]
  ! greaterThan     [ reduce using rule 40 (binop -> exp Equality exp .) ]
  ! Equality        [ shift and go to state 74 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 95

    (41) binop -> exp lessThan exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 41 (binop -> exp lessThan exp .)
    Equality        reduce using rule 41 (binop -> exp lessThan exp .)
    lessThan        reduce using rule 41 (binop -> exp lessThan exp .)
    greaterThan     reduce using rule 41 (binop -> exp lessThan exp .)
    logicalAnd      reduce using rule 41 (binop -> exp lessThan exp .)
    logicalOr       reduce using rule 41 (binop -> exp lessThan exp .)
    RParen          reduce using rule 41 (binop -> exp lessThan exp .)
    COMMA           reduce using rule 41 (binop -> exp lessThan exp .)
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73

  ! Multiply        [ reduce using rule 41 (binop -> exp lessThan exp .) ]
  ! PLUS            [ reduce using rule 41 (binop -> exp lessThan exp .) ]
  ! Divide          [ reduce using rule 41 (binop -> exp lessThan exp .) ]
  ! Minus           [ reduce using rule 41 (binop -> exp lessThan exp .) ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 96

    (42) binop -> exp greaterThan exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 42 (binop -> exp greaterThan exp .)
    Equality        reduce using rule 42 (binop -> exp greaterThan exp .)
    lessThan        reduce using rule 42 (binop -> exp greaterThan exp .)
    greaterThan     reduce using rule 42 (binop -> exp greaterThan exp .)
    logicalAnd      reduce using rule 42 (binop -> exp greaterThan exp .)
    logicalOr       reduce using rule 42 (binop -> exp greaterThan exp .)
    RParen          reduce using rule 42 (binop -> exp greaterThan exp .)
    COMMA           reduce using rule 42 (binop -> exp greaterThan exp .)
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73

  ! Multiply        [ reduce using rule 42 (binop -> exp greaterThan exp .) ]
  ! PLUS            [ reduce using rule 42 (binop -> exp greaterThan exp .) ]
  ! Divide          [ reduce using rule 42 (binop -> exp greaterThan exp .) ]
  ! Minus           [ reduce using rule 42 (binop -> exp greaterThan exp .) ]
  ! Equality        [ shift and go to state 74 ]
  ! lessThan        [ shift and go to state 75 ]
  ! greaterThan     [ shift and go to state 76 ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 97

    (43) binop -> exp logicalAnd exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 43 (binop -> exp logicalAnd exp .)
    logicalAnd      reduce using rule 43 (binop -> exp logicalAnd exp .)
    logicalOr       reduce using rule 43 (binop -> exp logicalAnd exp .)
    RParen          reduce using rule 43 (binop -> exp logicalAnd exp .)
    COMMA           reduce using rule 43 (binop -> exp logicalAnd exp .)
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76

  ! Multiply        [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! PLUS            [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! Divide          [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! Minus           [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! Equality        [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! lessThan        [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! greaterThan     [ reduce using rule 43 (binop -> exp logicalAnd exp .) ]
  ! logicalAnd      [ shift and go to state 77 ]
  ! logicalOr       [ shift and go to state 78 ]


state 98

    (44) binop -> exp logicalOr exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 44 (binop -> exp logicalOr exp .)
    logicalOr       reduce using rule 44 (binop -> exp logicalOr exp .)
    RParen          reduce using rule 44 (binop -> exp logicalOr exp .)
    COMMA           reduce using rule 44 (binop -> exp logicalOr exp .)
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77

  ! Multiply        [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! PLUS            [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! Divide          [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! Minus           [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! Equality        [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! lessThan        [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! greaterThan     [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! logicalAnd      [ reduce using rule 44 (binop -> exp logicalOr exp .) ]
  ! logicalOr       [ shift and go to state 78 ]


state 99

    (18) stmt -> vdecl Equal exp . Semicolon
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       shift and go to state 108
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 100

    (20) stmt -> While LParen exp . RParen stmt
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    RParen          shift and go to state 109
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 101

    (26) exp -> LParen exp RParen .

    Semicolon       reduce using rule 26 (exp -> LParen exp RParen .)
    Multiply        reduce using rule 26 (exp -> LParen exp RParen .)
    PLUS            reduce using rule 26 (exp -> LParen exp RParen .)
    Divide          reduce using rule 26 (exp -> LParen exp RParen .)
    Minus           reduce using rule 26 (exp -> LParen exp RParen .)
    Equality        reduce using rule 26 (exp -> LParen exp RParen .)
    lessThan        reduce using rule 26 (exp -> LParen exp RParen .)
    greaterThan     reduce using rule 26 (exp -> LParen exp RParen .)
    logicalAnd      reduce using rule 26 (exp -> LParen exp RParen .)
    logicalOr       reduce using rule 26 (exp -> LParen exp RParen .)
    RParen          reduce using rule 26 (exp -> LParen exp RParen .)
    COMMA           reduce using rule 26 (exp -> LParen exp RParen .)


state 102

    (21) stmt -> If LParen exp . RParen stmt
    (22) stmt -> If LParen exp . RParen stmt Else stmt
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    RParen          shift and go to state 110
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 103

    (23) stmt -> Print exp Semicolon .

    Return          reduce using rule 23 (stmt -> Print exp Semicolon .)
    While           reduce using rule 23 (stmt -> Print exp Semicolon .)
    If              reduce using rule 23 (stmt -> Print exp Semicolon .)
    Print           reduce using rule 23 (stmt -> Print exp Semicolon .)
    LBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    LParen          reduce using rule 23 (stmt -> Print exp Semicolon .)
    lit             reduce using rule 23 (stmt -> Print exp Semicolon .)
    slit            reduce using rule 23 (stmt -> Print exp Semicolon .)
    var             reduce using rule 23 (stmt -> Print exp Semicolon .)
    GLOBID          reduce using rule 23 (stmt -> Print exp Semicolon .)
    int             reduce using rule 23 (stmt -> Print exp Semicolon .)
    float           reduce using rule 23 (stmt -> Print exp Semicolon .)
    cint            reduce using rule 23 (stmt -> Print exp Semicolon .)
    sfloat          reduce using rule 23 (stmt -> Print exp Semicolon .)
    void            reduce using rule 23 (stmt -> Print exp Semicolon .)
    ref             reduce using rule 23 (stmt -> Print exp Semicolon .)
    noalias         reduce using rule 23 (stmt -> Print exp Semicolon .)
    Minus           reduce using rule 23 (stmt -> Print exp Semicolon .)
    logicalNegation reduce using rule 23 (stmt -> Print exp Semicolon .)
    RBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    Else            reduce using rule 23 (stmt -> Print exp Semicolon .)


state 104

    (39) binop -> var Equal exp .
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    Semicolon       reduce using rule 39 (binop -> var Equal exp .)
    RParen          reduce using rule 39 (binop -> var Equal exp .)
    COMMA           reduce using rule 39 (binop -> var Equal exp .)
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78

  ! Multiply        [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! PLUS            [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! Divide          [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! Minus           [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! Equality        [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! lessThan        [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! greaterThan     [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! logicalAnd      [ reduce using rule 39 (binop -> var Equal exp .) ]
  ! logicalOr       [ reduce using rule 39 (binop -> var Equal exp .) ]


state 105

    (33) expWrapper -> LParen RParen .

    Semicolon       reduce using rule 33 (expWrapper -> LParen RParen .)
    Multiply        reduce using rule 33 (expWrapper -> LParen RParen .)
    PLUS            reduce using rule 33 (expWrapper -> LParen RParen .)
    Divide          reduce using rule 33 (expWrapper -> LParen RParen .)
    Minus           reduce using rule 33 (expWrapper -> LParen RParen .)
    Equality        reduce using rule 33 (expWrapper -> LParen RParen .)
    lessThan        reduce using rule 33 (expWrapper -> LParen RParen .)
    greaterThan     reduce using rule 33 (expWrapper -> LParen RParen .)
    logicalAnd      reduce using rule 33 (expWrapper -> LParen RParen .)
    logicalOr       reduce using rule 33 (expWrapper -> LParen RParen .)
    RParen          reduce using rule 33 (expWrapper -> LParen RParen .)
    COMMA           reduce using rule 33 (expWrapper -> LParen RParen .)


state 106

    (34) expWrapper -> LParen exps . RParen

    RParen          shift and go to state 111


state 107

    (24) exps -> exp .
    (25) exps -> exp . COMMA exps
    (35) binop -> exp . Multiply exp
    (36) binop -> exp . PLUS exp
    (37) binop -> exp . Divide exp
    (38) binop -> exp . Minus exp
    (40) binop -> exp . Equality exp
    (41) binop -> exp . lessThan exp
    (42) binop -> exp . greaterThan exp
    (43) binop -> exp . logicalAnd exp
    (44) binop -> exp . logicalOr exp

    RParen          reduce using rule 24 (exps -> exp .)
    COMMA           shift and go to state 112
    Multiply        shift and go to state 70
    PLUS            shift and go to state 71
    Divide          shift and go to state 72
    Minus           shift and go to state 73
    Equality        shift and go to state 74
    lessThan        shift and go to state 75
    greaterThan     shift and go to state 76
    logicalAnd      shift and go to state 77
    logicalOr       shift and go to state 78


state 108

    (18) stmt -> vdecl Equal exp Semicolon .

    Return          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    While           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    If              reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Print           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LParen          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    lit             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    slit            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    var             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    GLOBID          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    int             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    float           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    cint            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    sfloat          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    void            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    ref             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    noalias         reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Minus           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    logicalNegation reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    RBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Else            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)


state 109

    (20) stmt -> While LParen exp RParen . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (49) vdecl -> . TYPE var
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    Return          shift and go to state 46
    While           shift and go to state 49
    If              shift and go to state 51
    Print           shift and go to state 52
    LBracket        shift and go to state 36
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 47
    stmt                           shift and go to state 113
    blk                            shift and go to state 45
    vdecl                          shift and go to state 48
    TYPE                           shift and go to state 27
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 110

    (21) stmt -> If LParen exp RParen . stmt
    (22) stmt -> If LParen exp RParen . stmt Else stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (49) vdecl -> . TYPE var
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    Return          shift and go to state 46
    While           shift and go to state 49
    If              shift and go to state 51
    Print           shift and go to state 52
    LBracket        shift and go to state 36
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 47
    stmt                           shift and go to state 114
    blk                            shift and go to state 45
    vdecl                          shift and go to state 48
    TYPE                           shift and go to state 27
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 111

    (34) expWrapper -> LParen exps RParen .

    Semicolon       reduce using rule 34 (expWrapper -> LParen exps RParen .)
    Multiply        reduce using rule 34 (expWrapper -> LParen exps RParen .)
    PLUS            reduce using rule 34 (expWrapper -> LParen exps RParen .)
    Divide          reduce using rule 34 (expWrapper -> LParen exps RParen .)
    Minus           reduce using rule 34 (expWrapper -> LParen exps RParen .)
    Equality        reduce using rule 34 (expWrapper -> LParen exps RParen .)
    lessThan        reduce using rule 34 (expWrapper -> LParen exps RParen .)
    greaterThan     reduce using rule 34 (expWrapper -> LParen exps RParen .)
    logicalAnd      reduce using rule 34 (expWrapper -> LParen exps RParen .)
    logicalOr       reduce using rule 34 (expWrapper -> LParen exps RParen .)
    RParen          reduce using rule 34 (expWrapper -> LParen exps RParen .)
    COMMA           reduce using rule 34 (expWrapper -> LParen exps RParen .)


state 112

    (25) exps -> exp COMMA . exps
    (24) exps -> . exp
    (25) exps -> . exp COMMA exps
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 107
    exps                           shift and go to state 115
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 113

    (20) stmt -> While LParen exp RParen stmt .

    Return          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    While           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    If              reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Print           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LParen          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    lit             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    slit            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    var             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    GLOBID          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    int             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    float           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    cint            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    sfloat          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    void            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    ref             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    noalias         reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Minus           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    logicalNegation reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    RBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Else            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)


state 114

    (21) stmt -> If LParen exp RParen stmt .
    (22) stmt -> If LParen exp RParen stmt . Else stmt

  ! shift/reduce conflict for Else resolved as shift
    Return          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    While           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    If              reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Print           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LParen          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    lit             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    slit            reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    var             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    GLOBID          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    int             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    float           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    cint            reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    sfloat          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    void            reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    ref             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    noalias         reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Minus           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    logicalNegation reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    RBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Else            shift and go to state 116

  ! Else            [ reduce using rule 21 (stmt -> If LParen exp RParen stmt .) ]


state 115

    (25) exps -> exp COMMA exps .

    RParen          reduce using rule 25 (exps -> exp COMMA exps .)


state 116

    (22) stmt -> If LParen exp RParen stmt Else . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (49) vdecl -> . TYPE var
    (26) exp -> . LParen exp RParen
    (27) exp -> . lit
    (28) exp -> . slit
    (29) exp -> . binop
    (30) exp -> . uop
    (31) exp -> . var
    (32) exp -> . GLOBID expWrapper
    (52) TYPE -> . int
    (53) TYPE -> . float
    (54) TYPE -> . cint
    (55) TYPE -> . sfloat
    (56) TYPE -> . void
    (57) TYPE -> . ref TYPE
    (58) TYPE -> . noalias ref TYPE
    (35) binop -> . exp Multiply exp
    (36) binop -> . exp PLUS exp
    (37) binop -> . exp Divide exp
    (38) binop -> . exp Minus exp
    (39) binop -> . var Equal exp
    (40) binop -> . exp Equality exp
    (41) binop -> . exp lessThan exp
    (42) binop -> . exp greaterThan exp
    (43) binop -> . exp logicalAnd exp
    (44) binop -> . exp logicalOr exp
    (45) uop -> . Minus exp
    (46) uop -> . logicalNegation exp

    Return          shift and go to state 46
    While           shift and go to state 49
    If              shift and go to state 51
    Print           shift and go to state 52
    LBracket        shift and go to state 36
    LParen          shift and go to state 50
    lit             shift and go to state 54
    slit            shift and go to state 55
    var             shift and go to state 53
    GLOBID          shift and go to state 58
    int             shift and go to state 12
    float           shift and go to state 13
    cint            shift and go to state 14
    sfloat          shift and go to state 15
    void            shift and go to state 16
    ref             shift and go to state 17
    noalias         shift and go to state 18
    Minus           shift and go to state 59
    logicalNegation shift and go to state 60

    exp                            shift and go to state 47
    stmt                           shift and go to state 117
    blk                            shift and go to state 45
    vdecl                          shift and go to state 48
    TYPE                           shift and go to state 27
    binop                          shift and go to state 56
    uop                            shift and go to state 57

state 117

    (22) stmt -> If LParen exp RParen stmt Else stmt .

    Return          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    While           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    If              reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Print           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LParen          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    lit             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    slit            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    var             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    GLOBID          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    int             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    float           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    cint            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    sfloat          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    void            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    ref             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    noalias         reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Minus           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    logicalNegation reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    RBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Else            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for Else in state 114 resolved as shift
